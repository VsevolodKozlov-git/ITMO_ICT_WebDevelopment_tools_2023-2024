{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u041a\u043e\u0437\u043b\u043e\u0432 \u0412\u0441\u0435\u0432\u043e\u043b\u043e\u0434 \u0414\u0435\u043d\u0438\u0441\u043e\u0432\u0438\u0447, \u0433\u0440\u0443\u043f\u043f\u0430 K33421","title":"\u041a\u043e\u0437\u043b\u043e\u0432 \u0412\u0441\u0435\u0432\u043e\u043b\u043e\u0434 \u0414\u0435\u043d\u0438\u0441\u043e\u0432\u0438\u0447, \u0433\u0440\u0443\u043f\u043f\u0430 K33421"},{"location":"#k33421","text":"","title":"\u041a\u043e\u0437\u043b\u043e\u0432 \u0412\u0441\u0435\u0432\u043e\u043b\u043e\u0434 \u0414\u0435\u043d\u0438\u0441\u043e\u0432\u0438\u0447, \u0433\u0440\u0443\u043f\u043f\u0430 K33421"},{"location":"lab1/auth/","text":"\u0410\u0443\u0442\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044f \u0418\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u044b from passlib.context import CryptContext from jose import JWTError, jwt from pathlib import Path from dotenv import dotenv_values import datetime from fastapi import Depends from fastapi.security import OAuth2PasswordBearer from typing import Annotated import db_queries #dotenv setup env_path = Path(__file__).parent / '.env' config = dotenv_values(env_path) # jwt setup SECRET_KEY = config['JWT_SECRET_KEY'] ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 800000 # hasher setup crypto_context = CryptContext(schemes=['bcrypt'], deprecated='auto') # auth scheme setup oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") def verify_password(provided_password, actual_hash): return crypto_context.verify(provided_password, actual_hash) def get_password_hash(password): return crypto_context.hash(password) def generate_token(username): to_encode = { 'exp': datetime.datetime.now() + datetime.timedelta( minutes=ACCESS_TOKEN_EXPIRE_MINUTES ), 'iat': datetime.datetime.now(), 'sub': username } return jwt.encode( to_encode, SECRET_KEY, algorithm=ALGORITHM ) def decode_token(token): return jwt.decode( token, SECRET_KEY, ALGORITHM ) def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]): return get_user_by_token(token) def get_user_by_token(token): token_data = decode_token(token) username = token_data['sub'] return db_queries.get_user_by_username(username) \u041a\u043e\u043d\u0435\u0447\u043d\u044b\u0435 \u0442\u043e\u0447\u043a\u0438 @app.post('/token/', status_code=200, tags=[Tags.user]) def create_api_token( user_login: models.UserLogin ) -> tp.TypedDict('token_response', {'access_token': str, 'token_type': str}): try: user_db = db_queries.get_user_by_username(user_login.username) except ValueError: raise HTTPException(status_code=400, detail=f'no user with username {user_login.username}') is_password_correct = auth.verify_password(user_login.password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail=f'Incorrect password for username: {user_login.username}') token = auth.generate_token(user_login.username) return {'access_token': token, 'token_type': 'bearer'} @app.post('/user/', status_code=201, tags=[Tags.user]) def create_user( user: models.UserRegister, session:Session=Depends(get_session_depends) )-> tp.TypedDict('Created message', {'msg': str}): hashed_password = auth.get_password_hash(user.password) user_data = user.dict() user_data['hashed_password'] = hashed_password user = models.User.model_validate(user_data) tools.add_object_to_db_and_refresh(session, user) return {'msg': \"Created\"} @app.put('/user/password/', status_code=201, tags=[Tags.user]) def change_user_password( user_password: models.UserChangePassword, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.TypedDict('password_put_response', {'msg': str}): is_password_correct = auth.verify_password(user_password.current_password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail='Incorrect current password') if user_password.new_password != user_password.new_password_verification: raise HTTPException(status_code=400, detail='Passwords don\\'t match') new_hash = auth.get_password_hash(user_password.new_password) user_db.hashed_password = new_hash session.add(user_db) session.commit() return {'msg': 'password changed'}","title":"\u0410\u0443\u0442\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044f"},{"location":"lab1/auth/#_1","text":"","title":"\u0410\u0443\u0442\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044f"},{"location":"lab1/auth/#_2","text":"from passlib.context import CryptContext from jose import JWTError, jwt from pathlib import Path from dotenv import dotenv_values import datetime from fastapi import Depends from fastapi.security import OAuth2PasswordBearer from typing import Annotated import db_queries #dotenv setup env_path = Path(__file__).parent / '.env' config = dotenv_values(env_path) # jwt setup SECRET_KEY = config['JWT_SECRET_KEY'] ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 800000 # hasher setup crypto_context = CryptContext(schemes=['bcrypt'], deprecated='auto') # auth scheme setup oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") def verify_password(provided_password, actual_hash): return crypto_context.verify(provided_password, actual_hash) def get_password_hash(password): return crypto_context.hash(password) def generate_token(username): to_encode = { 'exp': datetime.datetime.now() + datetime.timedelta( minutes=ACCESS_TOKEN_EXPIRE_MINUTES ), 'iat': datetime.datetime.now(), 'sub': username } return jwt.encode( to_encode, SECRET_KEY, algorithm=ALGORITHM ) def decode_token(token): return jwt.decode( token, SECRET_KEY, ALGORITHM ) def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]): return get_user_by_token(token) def get_user_by_token(token): token_data = decode_token(token) username = token_data['sub'] return db_queries.get_user_by_username(username)","title":"\u0418\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u044b"},{"location":"lab1/auth/#_3","text":"@app.post('/token/', status_code=200, tags=[Tags.user]) def create_api_token( user_login: models.UserLogin ) -> tp.TypedDict('token_response', {'access_token': str, 'token_type': str}): try: user_db = db_queries.get_user_by_username(user_login.username) except ValueError: raise HTTPException(status_code=400, detail=f'no user with username {user_login.username}') is_password_correct = auth.verify_password(user_login.password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail=f'Incorrect password for username: {user_login.username}') token = auth.generate_token(user_login.username) return {'access_token': token, 'token_type': 'bearer'} @app.post('/user/', status_code=201, tags=[Tags.user]) def create_user( user: models.UserRegister, session:Session=Depends(get_session_depends) )-> tp.TypedDict('Created message', {'msg': str}): hashed_password = auth.get_password_hash(user.password) user_data = user.dict() user_data['hashed_password'] = hashed_password user = models.User.model_validate(user_data) tools.add_object_to_db_and_refresh(session, user) return {'msg': \"Created\"} @app.put('/user/password/', status_code=201, tags=[Tags.user]) def change_user_password( user_password: models.UserChangePassword, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.TypedDict('password_put_response', {'msg': str}): is_password_correct = auth.verify_password(user_password.current_password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail='Incorrect current password') if user_password.new_password != user_password.new_password_verification: raise HTTPException(status_code=400, detail='Passwords don\\'t match') new_hash = auth.get_password_hash(user_password.new_password) user_db.hashed_password = new_hash session.add(user_db) session.commit() return {'msg': 'password changed'}","title":"\u041a\u043e\u043d\u0435\u0447\u043d\u044b\u0435 \u0442\u043e\u0447\u043a\u0438"},{"location":"lab1/db/","text":"\u0421\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u0411\u0414 from sqlmodel import SQLModel, Session, create_engine from dotenv import dotenv_values from pathlib import Path from contextlib import contextmanager env_path = Path(__file__).parent / '.env' config = dotenv_values(env_path) db_url = config['DB_ADMIN'] engine = create_engine(db_url) def init_db(): SQLModel.metadata.create_all(engine) @contextmanager def get_session_func() -> Session: session = Session(engine) try: yield session finally: session.close() def get_session_depends() -> Session: with Session(engine) as session: yield session","title":"\u0421\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u0411\u0414"},{"location":"lab1/db/#_1","text":"from sqlmodel import SQLModel, Session, create_engine from dotenv import dotenv_values from pathlib import Path from contextlib import contextmanager env_path = Path(__file__).parent / '.env' config = dotenv_values(env_path) db_url = config['DB_ADMIN'] engine = create_engine(db_url) def init_db(): SQLModel.metadata.create_all(engine) @contextmanager def get_session_func() -> Session: session = Session(engine) try: yield session finally: session.close() def get_session_depends() -> Session: with Session(engine) as session: yield session","title":"\u0421\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u0411\u0414"},{"location":"lab1/endpoints/","text":"Endpoints \u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043a\u043e\u043d\u0435\u0447\u043d\u044b\u043c\u0438 \u0442\u043e\u0447\u043a\u0430\u043c\u0438 from fastapi import HTTPException import models from sqlmodel import Session, select, SQLModel import typing as tp def add_object_to_db_and_refresh(session: Session, object: SQLModel): session.add(object) session.commit() session.refresh(object) class ProjectValidator: _object = None def __init__(self, session, user_id, object_id): self._session = session self._user_id = user_id self._object_id = object_id self._project = self._retrieve_project() @property def object(self) -> models.Project: if self._object is None: self._object = self._retrieve_object_or_exception() return self._object def _retrieve_project(self) -> models.Project: return self.object def _retrieve_object_or_exception(self) -> models.Project: project = self._session.get(models.Project, self._object_id) if project is None: raise HTTPException( status_code=404, detail=f'Project with id={self.object.id} is not found' ) return project def is_admin_or_exception(self): statement = select(models.ProjectUserLink) \\ .where(models.ProjectUserLink.user_id == self._user_id) \\ .where(models.ProjectUserLink.user_id == self._project.id) user_entries: tp.List[models.ProjectUserLink] = list( self._session.exec(statement).all() ) for entry in user_entries: if entry.role == models.Role.admin: return raise HTTPException( status_code=403, detail=f'you\\'re not admin of project with id={self._project.id}' ) def is_in_project_or_exception(self): statement = select(models.ProjectUserLink) \\ .where(models.ProjectUserLink.user_id == self._user_id) \\ .where(models.ProjectUserLink.user_id == self._project.id) user_entries: tp.List[models.ProjectUserLink] = list(self._session.exec(statement).all()) if len(user_entries) == 0: raise HTTPException( status_code=403, detail=f'You\\'re not allowed to view project with id={self._project.id}' ) class CategoryValidator(ProjectValidator): def _retrieve_project(self) -> models.Project: return self.object.project def _retrieve_object_or_exception(self) -> models.Category: category = self._session.get(models.Category, self._object_id) if category is None: raise HTTPException( status_code=404, detail=f'Category with id={self._object_id} is not found' ) return category class TaskValidator(CategoryValidator): def _retrieve_project(self) -> models.Project: return self.object.category.project def _retrieve_object_or_exception(self) -> models.Task: task = self._session.get(models.Task, self._object_id) if task is None: raise HTTPException( status_code=404, detail=f'Task with id={self._object_id} is not found' ) return task \u041a\u043e\u043d\u0435\u0447\u043d\u044b\u0435 \u0442\u043e\u0447\u043a\u0438 from fastapi import FastAPI, Depends, HTTPException import models from sqlmodel import Session, select from db import init_db, get_session_depends import db_queries import auth from enum import Enum import typing as tp from endpoints import endpoint_tools as tools app = FastAPI() class Tags(Enum): user = 'user' project = 'project' category = 'category' task = 'task' @app.on_event(\"startup\") def on_startup(): init_db() # ------------------Token----------------- @app.post('/token/', status_code=200, tags=[Tags.user]) def create_api_token( user_login: models.UserLogin ) -> tp.TypedDict('token_response', {'access_token': str, 'token_type': str}): try: user_db = db_queries.get_user_by_username(user_login.username) except ValueError: raise HTTPException(status_code=400, detail=f'no user with username {user_login.username}') is_password_correct = auth.verify_password(user_login.password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail=f'Incorrect password for username: {user_login.username}') token = auth.generate_token(user_login.username) return {'access_token': token, 'token_type': 'bearer'} # ------------------User------------------- @app.get('/user/{user_id}', status_code=200, tags=[Tags.user]) def get_user_by_id( user_id: int, session: Session = Depends(get_session_depends) ) -> models.UserGet: user = session.get(models.User, user_id) if user is None: raise HTTPException( status_code=404, detail=f'user with user_id={user_id} not found' ) user_get = models.UserGet.model_validate(user) return user_get @app.get('/user/', status_code=200, tags=[Tags.user]) def get_current_user( user_db:models.User = Depends(auth.get_current_user) ) -> models.UserGet: user_get = models.UserGet.model_validate(user_db) return user_get @app.get('/user/list/', status_code=200, tags=[Tags.user]) def get_list_of_users( session: Session = Depends(get_session_depends) )-> tp.List[models.UserGet]: query = select(models.User) user_db_list = session.exec(query).all() user_get_list = [ models.UserGet.model_validate(user) for user in user_db_list ] return user_get_list @app.post('/user/', status_code=201, tags=[Tags.user]) def create_user( user: models.UserRegister, session:Session=Depends(get_session_depends) )-> tp.TypedDict('Created message', {'msg': str}): hashed_password = auth.get_password_hash(user.password) user_data = user.dict() user_data['hashed_password'] = hashed_password user = models.User.model_validate(user_data) tools.add_object_to_db_and_refresh(session, user) return {'msg': \"Created\"} @app.put('/user/password/', status_code=201, tags=[Tags.user]) def change_user_password( user_password: models.UserChangePassword, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.TypedDict('password_put_response', {'msg': str}): is_password_correct = auth.verify_password(user_password.current_password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail='Incorrect current password') if user_password.new_password != user_password.new_password_verification: raise HTTPException(status_code=400, detail='Passwords don\\'t match') new_hash = auth.get_password_hash(user_password.new_password) user_db.hashed_password = new_hash session.add(user_db) session.commit() return {'msg': 'password changed'} # ------------Project--------------- @app.get('/project/{project_id}', status_code=200, tags=[Tags.project]) def get_project_info( project_id: int, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> models.ProjectBase: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object project_base = models.ProjectBase.model_validate(project) return project_base @app.get('/project/', status_code=200, tags=[Tags.project]) def get_user_project_list( user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ): statement = select(models.ProjectUserLink) \\ .where(models.ProjectUserLink.user_id == user_db.id) user_entries: tp.List[models.ProjectUserLink] = list(session.exec(statement).all()) return [entry.project for entry in user_entries] @app.post('/project/', status_code=201, tags=[Tags.project]) def create_project( project: models.ProjectBase, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.TypedDict('post_project', {'msg': str}): project = models.Project.model_validate(project) tools.add_object_to_db_and_refresh(session, project) # add creator as project admin link = models.ProjectUserLink( user_id=user_db.id, project_id=project.id, role=models.Role.admin ) tools.add_object_to_db_and_refresh(session, link) return {'msg': 'Created'} @app.get('/project/{project_id}/user/', status_code=200, tags=[Tags.project]) def get_list_of_users_in_project( project_id: int, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.List[models.UserGet]: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object users = project.users users_get = [models.UserGet.model_validate(user) for user in users] return users_get @app.post('/project/{project_id}/user/', status_code=200, tags=[Tags.project]) def add_user_to_project( project_id: int, user_in_project: models.UserInProjectForm, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('add_to_project', {'msg': str}): project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_admin_or_exception() data_for_link = user_in_project.dict() data_for_link['project_id'] = project_id link = models.ProjectUserLink.validate(data_for_link) tools.add_object_to_db_and_refresh(session, link) return {'msg': 'Created'} @app.get('/project/{project_id}/category/', status_code=200, tags=[Tags.project]) def get_project_categories( project_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.List[models.Category]: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object return project.categories @app.post('/project/{project_id}/category/', status_code=201, tags=[Tags.project]) def add_category_to_project( project_id: int, category: models.CategoryBase, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('add_category', {'msg': str, 'object': models.Category}): project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_admin_or_exception() category = category.dict() category['project_id'] = project_id category = models.Category.model_validate(category) tools.add_object_to_db_and_refresh(session, category) return {'msg': 'Created', 'object': category} @app.get('/project/{project_id}/task', status_code=200, tags=[Tags.project]) def get_project_tasks( project_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.List[models.CategoryWithBaseTasks]: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object return project.categories @app.get('/project/{project_id}/calendar_entries', status_code=200, tags=[Tags.project]) def get_project_calendar_entries( project_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.ProjectWithCalendarEntries: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project = project_validator.object project_validator.is_in_project_or_exception() project_with_entries = models.ProjectWithCalendarEntries.model_validate(project) return project_with_entries # -------------------Category--------------- @app.get('/category/{category_id}/', status_code=200, tags=[Tags.category]) def get_category_info( category_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.CategoryBase: category_validator = tools.CategoryValidator(session, user_db.id, category_id) category = category_validator.object category_validator.is_in_project_or_exception() category_base = models.CategoryBase.model_validate(category) return category_base @app.get('/category/{category_id}/task/', status_code=200, tags=[Tags.category]) def get_category_tasks( category_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ): category_validator = tools.CategoryValidator(session, user_db.id, category_id) category = category_validator.object category_validator.is_in_project_or_exception() category_with_tasks = models.CategoryWithBaseTasks.model_validate(category) return category_with_tasks @app.post('/category/{category_id}/task/', status_code=201, tags=[Tags.category]) def add_task_to_category( category_id: int, task: models.TaskBase, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('task added', {'msg': str, 'obj': models.Task}): category_validator = tools.CategoryValidator(session, user_db.id, category_id) category_validator.is_admin_or_exception() task_data = task.dict() task_data['category_id'] = category_id task = models.Task.model_validate(task_data) tools.add_object_to_db_and_refresh(session, task) return {'msg': 'Created', 'obj': task} @app.get('/category/{category_id}/calendar_entries', status_code=200, tags=[Tags.category]) def get_category_calendar_entries( category_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.CategoryWithEntries: category_validator = tools.CategoryValidator(session, user_db.id, category_id) category_validator.is_in_project_or_exception() category = category_validator.object category_with_entries = models.CategoryWithEntries.model_validate( category ) return category_with_entries # ----------------------------Tasks----------------------------- @app.get('/task/{task_id}', status_code=200, tags=[Tags.task]) def get_task_info( task_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.TaskBase: task_validator = tools.TaskValidator(session, user_db.id, task_id) task = task_validator.object task_validator.is_in_project_or_exception() task_base = models.TaskBase.model_validate(task) return task_base @app.post('/task/{task_id}/calendar_entries/', status_code=201, tags=[Tags.task]) def add_calendar_entry_to_task( task_id: int, calendar_entry: models.CalendarEntryBase, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('task added', {'msg': str, 'obj': models.CalendarEntry}): task_validator = tools.TaskValidator(session, user_db.id, task_id) task_validator.is_admin_or_exception() calendar_entry_data = calendar_entry.dict() calendar_entry_data['task_id'] = task_id calendar_entry = models.CalendarEntry.model_validate(calendar_entry_data) tools.add_object_to_db_and_refresh(session, calendar_entry) return {'msg': 'Created', 'obj': calendar_entry} @app.get('/task/{task_id}/calendar_entries/', status_code=200, tags=[Tags.task]) def get_task_calendar_entries( task_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.TaskWithEntries: task_validator = tools.TaskValidator(session, user_db.id, task_id) task = task_validator.object task_validator.is_in_project_or_exception() task_with_entries = models.TaskWithEntries.model_validate(task) return task_with_entries","title":"Endpoints"},{"location":"lab1/endpoints/#endpoints","text":"","title":"Endpoints"},{"location":"lab1/endpoints/#_1","text":"from fastapi import HTTPException import models from sqlmodel import Session, select, SQLModel import typing as tp def add_object_to_db_and_refresh(session: Session, object: SQLModel): session.add(object) session.commit() session.refresh(object) class ProjectValidator: _object = None def __init__(self, session, user_id, object_id): self._session = session self._user_id = user_id self._object_id = object_id self._project = self._retrieve_project() @property def object(self) -> models.Project: if self._object is None: self._object = self._retrieve_object_or_exception() return self._object def _retrieve_project(self) -> models.Project: return self.object def _retrieve_object_or_exception(self) -> models.Project: project = self._session.get(models.Project, self._object_id) if project is None: raise HTTPException( status_code=404, detail=f'Project with id={self.object.id} is not found' ) return project def is_admin_or_exception(self): statement = select(models.ProjectUserLink) \\ .where(models.ProjectUserLink.user_id == self._user_id) \\ .where(models.ProjectUserLink.user_id == self._project.id) user_entries: tp.List[models.ProjectUserLink] = list( self._session.exec(statement).all() ) for entry in user_entries: if entry.role == models.Role.admin: return raise HTTPException( status_code=403, detail=f'you\\'re not admin of project with id={self._project.id}' ) def is_in_project_or_exception(self): statement = select(models.ProjectUserLink) \\ .where(models.ProjectUserLink.user_id == self._user_id) \\ .where(models.ProjectUserLink.user_id == self._project.id) user_entries: tp.List[models.ProjectUserLink] = list(self._session.exec(statement).all()) if len(user_entries) == 0: raise HTTPException( status_code=403, detail=f'You\\'re not allowed to view project with id={self._project.id}' ) class CategoryValidator(ProjectValidator): def _retrieve_project(self) -> models.Project: return self.object.project def _retrieve_object_or_exception(self) -> models.Category: category = self._session.get(models.Category, self._object_id) if category is None: raise HTTPException( status_code=404, detail=f'Category with id={self._object_id} is not found' ) return category class TaskValidator(CategoryValidator): def _retrieve_project(self) -> models.Project: return self.object.category.project def _retrieve_object_or_exception(self) -> models.Task: task = self._session.get(models.Task, self._object_id) if task is None: raise HTTPException( status_code=404, detail=f'Task with id={self._object_id} is not found' ) return task","title":"\u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043a\u043e\u043d\u0435\u0447\u043d\u044b\u043c\u0438 \u0442\u043e\u0447\u043a\u0430\u043c\u0438"},{"location":"lab1/endpoints/#_2","text":"from fastapi import FastAPI, Depends, HTTPException import models from sqlmodel import Session, select from db import init_db, get_session_depends import db_queries import auth from enum import Enum import typing as tp from endpoints import endpoint_tools as tools app = FastAPI() class Tags(Enum): user = 'user' project = 'project' category = 'category' task = 'task' @app.on_event(\"startup\") def on_startup(): init_db() # ------------------Token----------------- @app.post('/token/', status_code=200, tags=[Tags.user]) def create_api_token( user_login: models.UserLogin ) -> tp.TypedDict('token_response', {'access_token': str, 'token_type': str}): try: user_db = db_queries.get_user_by_username(user_login.username) except ValueError: raise HTTPException(status_code=400, detail=f'no user with username {user_login.username}') is_password_correct = auth.verify_password(user_login.password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail=f'Incorrect password for username: {user_login.username}') token = auth.generate_token(user_login.username) return {'access_token': token, 'token_type': 'bearer'} # ------------------User------------------- @app.get('/user/{user_id}', status_code=200, tags=[Tags.user]) def get_user_by_id( user_id: int, session: Session = Depends(get_session_depends) ) -> models.UserGet: user = session.get(models.User, user_id) if user is None: raise HTTPException( status_code=404, detail=f'user with user_id={user_id} not found' ) user_get = models.UserGet.model_validate(user) return user_get @app.get('/user/', status_code=200, tags=[Tags.user]) def get_current_user( user_db:models.User = Depends(auth.get_current_user) ) -> models.UserGet: user_get = models.UserGet.model_validate(user_db) return user_get @app.get('/user/list/', status_code=200, tags=[Tags.user]) def get_list_of_users( session: Session = Depends(get_session_depends) )-> tp.List[models.UserGet]: query = select(models.User) user_db_list = session.exec(query).all() user_get_list = [ models.UserGet.model_validate(user) for user in user_db_list ] return user_get_list @app.post('/user/', status_code=201, tags=[Tags.user]) def create_user( user: models.UserRegister, session:Session=Depends(get_session_depends) )-> tp.TypedDict('Created message', {'msg': str}): hashed_password = auth.get_password_hash(user.password) user_data = user.dict() user_data['hashed_password'] = hashed_password user = models.User.model_validate(user_data) tools.add_object_to_db_and_refresh(session, user) return {'msg': \"Created\"} @app.put('/user/password/', status_code=201, tags=[Tags.user]) def change_user_password( user_password: models.UserChangePassword, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.TypedDict('password_put_response', {'msg': str}): is_password_correct = auth.verify_password(user_password.current_password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail='Incorrect current password') if user_password.new_password != user_password.new_password_verification: raise HTTPException(status_code=400, detail='Passwords don\\'t match') new_hash = auth.get_password_hash(user_password.new_password) user_db.hashed_password = new_hash session.add(user_db) session.commit() return {'msg': 'password changed'} # ------------Project--------------- @app.get('/project/{project_id}', status_code=200, tags=[Tags.project]) def get_project_info( project_id: int, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> models.ProjectBase: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object project_base = models.ProjectBase.model_validate(project) return project_base @app.get('/project/', status_code=200, tags=[Tags.project]) def get_user_project_list( user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ): statement = select(models.ProjectUserLink) \\ .where(models.ProjectUserLink.user_id == user_db.id) user_entries: tp.List[models.ProjectUserLink] = list(session.exec(statement).all()) return [entry.project for entry in user_entries] @app.post('/project/', status_code=201, tags=[Tags.project]) def create_project( project: models.ProjectBase, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.TypedDict('post_project', {'msg': str}): project = models.Project.model_validate(project) tools.add_object_to_db_and_refresh(session, project) # add creator as project admin link = models.ProjectUserLink( user_id=user_db.id, project_id=project.id, role=models.Role.admin ) tools.add_object_to_db_and_refresh(session, link) return {'msg': 'Created'} @app.get('/project/{project_id}/user/', status_code=200, tags=[Tags.project]) def get_list_of_users_in_project( project_id: int, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.List[models.UserGet]: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object users = project.users users_get = [models.UserGet.model_validate(user) for user in users] return users_get @app.post('/project/{project_id}/user/', status_code=200, tags=[Tags.project]) def add_user_to_project( project_id: int, user_in_project: models.UserInProjectForm, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('add_to_project', {'msg': str}): project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_admin_or_exception() data_for_link = user_in_project.dict() data_for_link['project_id'] = project_id link = models.ProjectUserLink.validate(data_for_link) tools.add_object_to_db_and_refresh(session, link) return {'msg': 'Created'} @app.get('/project/{project_id}/category/', status_code=200, tags=[Tags.project]) def get_project_categories( project_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.List[models.Category]: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object return project.categories @app.post('/project/{project_id}/category/', status_code=201, tags=[Tags.project]) def add_category_to_project( project_id: int, category: models.CategoryBase, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('add_category', {'msg': str, 'object': models.Category}): project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_admin_or_exception() category = category.dict() category['project_id'] = project_id category = models.Category.model_validate(category) tools.add_object_to_db_and_refresh(session, category) return {'msg': 'Created', 'object': category} @app.get('/project/{project_id}/task', status_code=200, tags=[Tags.project]) def get_project_tasks( project_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.List[models.CategoryWithBaseTasks]: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object return project.categories @app.get('/project/{project_id}/calendar_entries', status_code=200, tags=[Tags.project]) def get_project_calendar_entries( project_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.ProjectWithCalendarEntries: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project = project_validator.object project_validator.is_in_project_or_exception() project_with_entries = models.ProjectWithCalendarEntries.model_validate(project) return project_with_entries # -------------------Category--------------- @app.get('/category/{category_id}/', status_code=200, tags=[Tags.category]) def get_category_info( category_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.CategoryBase: category_validator = tools.CategoryValidator(session, user_db.id, category_id) category = category_validator.object category_validator.is_in_project_or_exception() category_base = models.CategoryBase.model_validate(category) return category_base @app.get('/category/{category_id}/task/', status_code=200, tags=[Tags.category]) def get_category_tasks( category_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ): category_validator = tools.CategoryValidator(session, user_db.id, category_id) category = category_validator.object category_validator.is_in_project_or_exception() category_with_tasks = models.CategoryWithBaseTasks.model_validate(category) return category_with_tasks @app.post('/category/{category_id}/task/', status_code=201, tags=[Tags.category]) def add_task_to_category( category_id: int, task: models.TaskBase, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('task added', {'msg': str, 'obj': models.Task}): category_validator = tools.CategoryValidator(session, user_db.id, category_id) category_validator.is_admin_or_exception() task_data = task.dict() task_data['category_id'] = category_id task = models.Task.model_validate(task_data) tools.add_object_to_db_and_refresh(session, task) return {'msg': 'Created', 'obj': task} @app.get('/category/{category_id}/calendar_entries', status_code=200, tags=[Tags.category]) def get_category_calendar_entries( category_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.CategoryWithEntries: category_validator = tools.CategoryValidator(session, user_db.id, category_id) category_validator.is_in_project_or_exception() category = category_validator.object category_with_entries = models.CategoryWithEntries.model_validate( category ) return category_with_entries # ----------------------------Tasks----------------------------- @app.get('/task/{task_id}', status_code=200, tags=[Tags.task]) def get_task_info( task_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.TaskBase: task_validator = tools.TaskValidator(session, user_db.id, task_id) task = task_validator.object task_validator.is_in_project_or_exception() task_base = models.TaskBase.model_validate(task) return task_base @app.post('/task/{task_id}/calendar_entries/', status_code=201, tags=[Tags.task]) def add_calendar_entry_to_task( task_id: int, calendar_entry: models.CalendarEntryBase, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('task added', {'msg': str, 'obj': models.CalendarEntry}): task_validator = tools.TaskValidator(session, user_db.id, task_id) task_validator.is_admin_or_exception() calendar_entry_data = calendar_entry.dict() calendar_entry_data['task_id'] = task_id calendar_entry = models.CalendarEntry.model_validate(calendar_entry_data) tools.add_object_to_db_and_refresh(session, calendar_entry) return {'msg': 'Created', 'obj': calendar_entry} @app.get('/task/{task_id}/calendar_entries/', status_code=200, tags=[Tags.task]) def get_task_calendar_entries( task_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.TaskWithEntries: task_validator = tools.TaskValidator(session, user_db.id, task_id) task = task_validator.object task_validator.is_in_project_or_exception() task_with_entries = models.TaskWithEntries.model_validate(task) return task_with_entries","title":"\u041a\u043e\u043d\u0435\u0447\u043d\u044b\u0435 \u0442\u043e\u0447\u043a\u0438"},{"location":"lab1/models/","text":"\u041c\u043e\u0434\u0435\u043b\u0438 \u0421\u0445\u0435\u043c\u0430 \u0411\u0414 \u041a\u043e\u0434 \u0434\u043b\u044f \u043c\u043e\u0434\u0435\u043b\u0435\u0439 from sqlmodel import SQLModel,Field, select, Relationship import pydantic from db import get_session_func from enum import Enum from typing import Optional, Type, List import datetime def is_in_table(model: Type[SQLModel], field, unique_value): with get_session_func() as session: statement = select(model).where(field == unique_value) result = list(session.exec(statement)) return len(result) > 0 class Role(Enum): admin = 'admin' viewer = 'viewer' class Priority(Enum): low = 0 medium = 1 high = 2 class ProjectUserLink(SQLModel, table=True): id: int = Field(default=None, primary_key=True) user_id: int = Field(foreign_key='user.id') user: 'User' = Relationship() project_id: int = Field(foreign_key='project.id') project: 'Project' = Relationship() role: Role class UserInProjectForm(SQLModel): user_id: int role: Role class UserSuperBase(SQLModel): username: str = Field(unique=True) email: str @pydantic.field_validator('email') @classmethod def validate_email(cls, value: str) -> str: pydantic.EmailStr._validate(value) return value @pydantic.field_validator('username') @classmethod def validate_username(cls, value: str) -> str: if is_in_table(User, User.username, value): raise ValueError('username is not unique') return value class UserBase(UserSuperBase): hashed_password: str class UserRegister(UserSuperBase): password: str class UserLogin(SQLModel): username: str password: str class UserGet(SQLModel): username: str email: str class UserChangePassword(SQLModel): current_password: str new_password: str new_password_verification: str class User(UserBase, table=True): id: int = Field(default=None, primary_key=True) projects: List['Project'] = Relationship(back_populates='users', link_model=ProjectUserLink) class ProjectBase(SQLModel): title: str description: Optional[str] class Project(ProjectBase, table=True): id: int = Field(default=None, primary_key=True) users: List[User] = Relationship(back_populates='projects', link_model=ProjectUserLink) categories: List['Category'] = Relationship(back_populates='project') class ProjectWithCalendarEntries(ProjectBase): categories: List['CategoryWithEntries'] class CategoryBase(SQLModel): title: str description: Optional[str] class Category(CategoryBase, table=True): id: int = Field(default=None, primary_key=True) # \u043e\u0442\u0432\u0435\u0447\u0430\u0435\u0442 \u0437\u0430 \u0440\u0435\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u043e\u043b\u0435 \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 project_id: int = Field(foreign_key='project.id') # \u043e\u0442\u0432\u0435\u0447\u0430\u0435\u0442 \u0437\u0430 category.project \u0438 project.categories project: Project = Relationship(back_populates='categories') tasks: List['Task'] = Relationship(back_populates='category') class CategoryWithBaseTasks(CategoryBase): tasks: List['TaskBase'] class CategoryWithEntries(CategoryBase): tasks: List['TaskWithEntries'] class TaskBase(SQLModel): title: str description: Optional[str] deadline: Optional[int] priority: Priority approximate_time: datetime.time class Task(TaskBase, table=True): id: int = Field(default=None, primary_key=True) category_id: int = Field(foreign_key='category.id') category: Category = Relationship(back_populates='tasks') calendar_entries: List['CalendarEntry'] = Relationship(back_populates='task') class TaskGet(TaskBase): Category: Category class CalendarEntryBase(SQLModel): start_time: datetime.datetime end_time: datetime.datetime class CalendarEntry(CalendarEntryBase, table=True): id: int = Field(default=None, primary_key=True) task_id: int = Field(foreign_key='task.id') task: Task = Relationship(back_populates='calendar_entries') class CalendarEntryWithId(CalendarEntryBase): id: int class TaskWithEntries(TaskBase): calendar_entries: List[CalendarEntryWithId]","title":"\u041c\u043e\u0434\u0435\u043b\u0438"},{"location":"lab1/models/#_1","text":"","title":"\u041c\u043e\u0434\u0435\u043b\u0438"},{"location":"lab1/models/#_2","text":"","title":"\u0421\u0445\u0435\u043c\u0430 \u0411\u0414"},{"location":"lab1/models/#_3","text":"from sqlmodel import SQLModel,Field, select, Relationship import pydantic from db import get_session_func from enum import Enum from typing import Optional, Type, List import datetime def is_in_table(model: Type[SQLModel], field, unique_value): with get_session_func() as session: statement = select(model).where(field == unique_value) result = list(session.exec(statement)) return len(result) > 0 class Role(Enum): admin = 'admin' viewer = 'viewer' class Priority(Enum): low = 0 medium = 1 high = 2 class ProjectUserLink(SQLModel, table=True): id: int = Field(default=None, primary_key=True) user_id: int = Field(foreign_key='user.id') user: 'User' = Relationship() project_id: int = Field(foreign_key='project.id') project: 'Project' = Relationship() role: Role class UserInProjectForm(SQLModel): user_id: int role: Role class UserSuperBase(SQLModel): username: str = Field(unique=True) email: str @pydantic.field_validator('email') @classmethod def validate_email(cls, value: str) -> str: pydantic.EmailStr._validate(value) return value @pydantic.field_validator('username') @classmethod def validate_username(cls, value: str) -> str: if is_in_table(User, User.username, value): raise ValueError('username is not unique') return value class UserBase(UserSuperBase): hashed_password: str class UserRegister(UserSuperBase): password: str class UserLogin(SQLModel): username: str password: str class UserGet(SQLModel): username: str email: str class UserChangePassword(SQLModel): current_password: str new_password: str new_password_verification: str class User(UserBase, table=True): id: int = Field(default=None, primary_key=True) projects: List['Project'] = Relationship(back_populates='users', link_model=ProjectUserLink) class ProjectBase(SQLModel): title: str description: Optional[str] class Project(ProjectBase, table=True): id: int = Field(default=None, primary_key=True) users: List[User] = Relationship(back_populates='projects', link_model=ProjectUserLink) categories: List['Category'] = Relationship(back_populates='project') class ProjectWithCalendarEntries(ProjectBase): categories: List['CategoryWithEntries'] class CategoryBase(SQLModel): title: str description: Optional[str] class Category(CategoryBase, table=True): id: int = Field(default=None, primary_key=True) # \u043e\u0442\u0432\u0435\u0447\u0430\u0435\u0442 \u0437\u0430 \u0440\u0435\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u043e\u043b\u0435 \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 project_id: int = Field(foreign_key='project.id') # \u043e\u0442\u0432\u0435\u0447\u0430\u0435\u0442 \u0437\u0430 category.project \u0438 project.categories project: Project = Relationship(back_populates='categories') tasks: List['Task'] = Relationship(back_populates='category') class CategoryWithBaseTasks(CategoryBase): tasks: List['TaskBase'] class CategoryWithEntries(CategoryBase): tasks: List['TaskWithEntries'] class TaskBase(SQLModel): title: str description: Optional[str] deadline: Optional[int] priority: Priority approximate_time: datetime.time class Task(TaskBase, table=True): id: int = Field(default=None, primary_key=True) category_id: int = Field(foreign_key='category.id') category: Category = Relationship(back_populates='tasks') calendar_entries: List['CalendarEntry'] = Relationship(back_populates='task') class TaskGet(TaskBase): Category: Category class CalendarEntryBase(SQLModel): start_time: datetime.datetime end_time: datetime.datetime class CalendarEntry(CalendarEntryBase, table=True): id: int = Field(default=None, primary_key=True) task_id: int = Field(foreign_key='task.id') task: Task = Relationship(back_populates='calendar_entries') class CalendarEntryWithId(CalendarEntryBase): id: int class TaskWithEntries(TaskBase): calendar_entries: List[CalendarEntryWithId]","title":"\u041a\u043e\u0434 \u0434\u043b\u044f \u043c\u043e\u0434\u0435\u043b\u0435\u0439"},{"location":"lab1/practice/","text":"\u041f\u0440\u0430\u043a\u0442\u0438\u043a\u0430 \u041f\u0440\u0430\u043a\u0442\u0438\u043a\u0430 1 - \u0441\u0441\u044b\u043b\u043a\u0430 \u041f\u0440\u0430\u043a\u0442\u0438\u043a\u0430 2/3 - \u0441\u0441\u044b\u043b\u043a\u0430","title":"\u041f\u0440\u0430\u043a\u0442\u0438\u043a\u0430"},{"location":"lab1/practice/#_1","text":"\u041f\u0440\u0430\u043a\u0442\u0438\u043a\u0430 1 - \u0441\u0441\u044b\u043b\u043a\u0430 \u041f\u0440\u0430\u043a\u0442\u0438\u043a\u0430 2/3 - \u0441\u0441\u044b\u043b\u043a\u0430","title":"\u041f\u0440\u0430\u043a\u0442\u0438\u043a\u0430"}]}