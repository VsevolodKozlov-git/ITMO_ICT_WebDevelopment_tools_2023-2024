{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u041a\u043e\u0437\u043b\u043e\u0432 \u0412\u0441\u0435\u0432\u043e\u043b\u043e\u0434 \u0414\u0435\u043d\u0438\u0441\u043e\u0432\u0438\u0447, \u0433\u0440\u0443\u043f\u043f\u0430 K33421","title":"\u041a\u043e\u0437\u043b\u043e\u0432 \u0412\u0441\u0435\u0432\u043e\u043b\u043e\u0434 \u0414\u0435\u043d\u0438\u0441\u043e\u0432\u0438\u0447, \u0433\u0440\u0443\u043f\u043f\u0430 K33421"},{"location":"#k33421","text":"","title":"\u041a\u043e\u0437\u043b\u043e\u0432 \u0412\u0441\u0435\u0432\u043e\u043b\u043e\u0434 \u0414\u0435\u043d\u0438\u0441\u043e\u0432\u0438\u0447, \u0433\u0440\u0443\u043f\u043f\u0430 K33421"},{"location":"lab1/auth/","text":"\u0410\u0443\u0442\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044f \u0418\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u044b from passlib.context import CryptContext from jose import JWTError, jwt from pathlib import Path from dotenv import dotenv_values import datetime from fastapi import Depends from fastapi.security import OAuth2PasswordBearer from typing import Annotated import db_queries #dotenv setup env_path = Path(__file__).parent / '.env' config = dotenv_values(env_path) # jwt setup SECRET_KEY = config['JWT_SECRET_KEY'] ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 800000 # hasher setup crypto_context = CryptContext(schemes=['bcrypt'], deprecated='auto') # auth scheme setup oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") def verify_password(provided_password, actual_hash): return crypto_context.verify(provided_password, actual_hash) def get_password_hash(password): return crypto_context.hash(password) def generate_token(username): to_encode = { 'exp': datetime.datetime.now() + datetime.timedelta( minutes=ACCESS_TOKEN_EXPIRE_MINUTES ), 'iat': datetime.datetime.now(), 'sub': username } return jwt.encode( to_encode, SECRET_KEY, algorithm=ALGORITHM ) def decode_token(token): return jwt.decode( token, SECRET_KEY, ALGORITHM ) def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]): return get_user_by_token(token) def get_user_by_token(token): token_data = decode_token(token) username = token_data['sub'] return db_queries.get_user_by_username(username) \u041a\u043e\u043d\u0435\u0447\u043d\u044b\u0435 \u0442\u043e\u0447\u043a\u0438 @app.post('/token/', status_code=200, tags=[Tags.user]) def create_api_token( user_login: models.UserLogin ) -> tp.TypedDict('token_response', {'access_token': str, 'token_type': str}): try: user_db = db_queries.get_user_by_username(user_login.username) except ValueError: raise HTTPException(status_code=400, detail=f'no user with username {user_login.username}') is_password_correct = auth.verify_password(user_login.password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail=f'Incorrect password for username: {user_login.username}') token = auth.generate_token(user_login.username) return {'access_token': token, 'token_type': 'bearer'} @app.post('/user/', status_code=201, tags=[Tags.user]) def create_user( user: models.UserRegister, session:Session=Depends(get_session_depends) )-> tp.TypedDict('Created message', {'msg': str}): hashed_password = auth.get_password_hash(user.password) user_data = user.dict() user_data['hashed_password'] = hashed_password user = models.User.model_validate(user_data) tools.add_object_to_db_and_refresh(session, user) return {'msg': \"Created\"} @app.put('/user/password/', status_code=201, tags=[Tags.user]) def change_user_password( user_password: models.UserChangePassword, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.TypedDict('password_put_response', {'msg': str}): is_password_correct = auth.verify_password(user_password.current_password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail='Incorrect current password') if user_password.new_password != user_password.new_password_verification: raise HTTPException(status_code=400, detail='Passwords don\\'t match') new_hash = auth.get_password_hash(user_password.new_password) user_db.hashed_password = new_hash session.add(user_db) session.commit() return {'msg': 'password changed'}","title":"\u0410\u0443\u0442\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044f"},{"location":"lab1/auth/#_1","text":"","title":"\u0410\u0443\u0442\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u044f"},{"location":"lab1/auth/#_2","text":"from passlib.context import CryptContext from jose import JWTError, jwt from pathlib import Path from dotenv import dotenv_values import datetime from fastapi import Depends from fastapi.security import OAuth2PasswordBearer from typing import Annotated import db_queries #dotenv setup env_path = Path(__file__).parent / '.env' config = dotenv_values(env_path) # jwt setup SECRET_KEY = config['JWT_SECRET_KEY'] ALGORITHM = \"HS256\" ACCESS_TOKEN_EXPIRE_MINUTES = 800000 # hasher setup crypto_context = CryptContext(schemes=['bcrypt'], deprecated='auto') # auth scheme setup oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\") def verify_password(provided_password, actual_hash): return crypto_context.verify(provided_password, actual_hash) def get_password_hash(password): return crypto_context.hash(password) def generate_token(username): to_encode = { 'exp': datetime.datetime.now() + datetime.timedelta( minutes=ACCESS_TOKEN_EXPIRE_MINUTES ), 'iat': datetime.datetime.now(), 'sub': username } return jwt.encode( to_encode, SECRET_KEY, algorithm=ALGORITHM ) def decode_token(token): return jwt.decode( token, SECRET_KEY, ALGORITHM ) def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]): return get_user_by_token(token) def get_user_by_token(token): token_data = decode_token(token) username = token_data['sub'] return db_queries.get_user_by_username(username)","title":"\u0418\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u044b"},{"location":"lab1/auth/#_3","text":"@app.post('/token/', status_code=200, tags=[Tags.user]) def create_api_token( user_login: models.UserLogin ) -> tp.TypedDict('token_response', {'access_token': str, 'token_type': str}): try: user_db = db_queries.get_user_by_username(user_login.username) except ValueError: raise HTTPException(status_code=400, detail=f'no user with username {user_login.username}') is_password_correct = auth.verify_password(user_login.password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail=f'Incorrect password for username: {user_login.username}') token = auth.generate_token(user_login.username) return {'access_token': token, 'token_type': 'bearer'} @app.post('/user/', status_code=201, tags=[Tags.user]) def create_user( user: models.UserRegister, session:Session=Depends(get_session_depends) )-> tp.TypedDict('Created message', {'msg': str}): hashed_password = auth.get_password_hash(user.password) user_data = user.dict() user_data['hashed_password'] = hashed_password user = models.User.model_validate(user_data) tools.add_object_to_db_and_refresh(session, user) return {'msg': \"Created\"} @app.put('/user/password/', status_code=201, tags=[Tags.user]) def change_user_password( user_password: models.UserChangePassword, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.TypedDict('password_put_response', {'msg': str}): is_password_correct = auth.verify_password(user_password.current_password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail='Incorrect current password') if user_password.new_password != user_password.new_password_verification: raise HTTPException(status_code=400, detail='Passwords don\\'t match') new_hash = auth.get_password_hash(user_password.new_password) user_db.hashed_password = new_hash session.add(user_db) session.commit() return {'msg': 'password changed'}","title":"\u041a\u043e\u043d\u0435\u0447\u043d\u044b\u0435 \u0442\u043e\u0447\u043a\u0438"},{"location":"lab1/db/","text":"\u0421\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u0411\u0414 from sqlmodel import SQLModel, Session, create_engine from dotenv import dotenv_values from pathlib import Path from contextlib import contextmanager env_path = Path(__file__).parent / '.env' config = dotenv_values(env_path) db_url = config['DB_ADMIN'] engine = create_engine(db_url) def init_db(): SQLModel.metadata.create_all(engine) @contextmanager def get_session_func() -> Session: session = Session(engine) try: yield session finally: session.close() def get_session_depends() -> Session: with Session(engine) as session: yield session","title":"\u0421\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u0411\u0414"},{"location":"lab1/db/#_1","text":"from sqlmodel import SQLModel, Session, create_engine from dotenv import dotenv_values from pathlib import Path from contextlib import contextmanager env_path = Path(__file__).parent / '.env' config = dotenv_values(env_path) db_url = config['DB_ADMIN'] engine = create_engine(db_url) def init_db(): SQLModel.metadata.create_all(engine) @contextmanager def get_session_func() -> Session: session = Session(engine) try: yield session finally: session.close() def get_session_depends() -> Session: with Session(engine) as session: yield session","title":"\u0421\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u0411\u0414"},{"location":"lab1/endpoints/","text":"Endpoints \u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043a\u043e\u043d\u0435\u0447\u043d\u044b\u043c\u0438 \u0442\u043e\u0447\u043a\u0430\u043c\u0438 from fastapi import HTTPException import models from sqlmodel import Session, select, SQLModel import typing as tp def add_object_to_db_and_refresh(session: Session, object: SQLModel): session.add(object) session.commit() session.refresh(object) class ProjectValidator: _object = None def __init__(self, session, user_id, object_id): self._session = session self._user_id = user_id self._object_id = object_id self._project = self._retrieve_project() @property def object(self) -> models.Project: if self._object is None: self._object = self._retrieve_object_or_exception() return self._object def _retrieve_project(self) -> models.Project: return self.object def _retrieve_object_or_exception(self) -> models.Project: project = self._session.get(models.Project, self._object_id) if project is None: raise HTTPException( status_code=404, detail=f'Project with id={self.object.id} is not found' ) return project def is_admin_or_exception(self): statement = select(models.ProjectUserLink) \\ .where(models.ProjectUserLink.user_id == self._user_id) \\ .where(models.ProjectUserLink.user_id == self._project.id) user_entries: tp.List[models.ProjectUserLink] = list( self._session.exec(statement).all() ) for entry in user_entries: if entry.role == models.Role.admin: return raise HTTPException( status_code=403, detail=f'you\\'re not admin of project with id={self._project.id}' ) def is_in_project_or_exception(self): statement = select(models.ProjectUserLink) \\ .where(models.ProjectUserLink.user_id == self._user_id) \\ .where(models.ProjectUserLink.user_id == self._project.id) user_entries: tp.List[models.ProjectUserLink] = list(self._session.exec(statement).all()) if len(user_entries) == 0: raise HTTPException( status_code=403, detail=f'You\\'re not allowed to view project with id={self._project.id}' ) class CategoryValidator(ProjectValidator): def _retrieve_project(self) -> models.Project: return self.object.project def _retrieve_object_or_exception(self) -> models.Category: category = self._session.get(models.Category, self._object_id) if category is None: raise HTTPException( status_code=404, detail=f'Category with id={self._object_id} is not found' ) return category class TaskValidator(CategoryValidator): def _retrieve_project(self) -> models.Project: return self.object.category.project def _retrieve_object_or_exception(self) -> models.Task: task = self._session.get(models.Task, self._object_id) if task is None: raise HTTPException( status_code=404, detail=f'Task with id={self._object_id} is not found' ) return task \u041a\u043e\u043d\u0435\u0447\u043d\u044b\u0435 \u0442\u043e\u0447\u043a\u0438 from fastapi import FastAPI, Depends, HTTPException import models from sqlmodel import Session, select from db import init_db, get_session_depends import db_queries import auth from enum import Enum import typing as tp from endpoints import endpoint_tools as tools app = FastAPI() class Tags(Enum): user = 'user' project = 'project' category = 'category' task = 'task' @app.on_event(\"startup\") def on_startup(): init_db() # ------------------Token----------------- @app.post('/token/', status_code=200, tags=[Tags.user]) def create_api_token( user_login: models.UserLogin ) -> tp.TypedDict('token_response', {'access_token': str, 'token_type': str}): try: user_db = db_queries.get_user_by_username(user_login.username) except ValueError: raise HTTPException(status_code=400, detail=f'no user with username {user_login.username}') is_password_correct = auth.verify_password(user_login.password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail=f'Incorrect password for username: {user_login.username}') token = auth.generate_token(user_login.username) return {'access_token': token, 'token_type': 'bearer'} # ------------------User------------------- @app.get('/user/{user_id}', status_code=200, tags=[Tags.user]) def get_user_by_id( user_id: int, session: Session = Depends(get_session_depends) ) -> models.UserGet: user = session.get(models.User, user_id) if user is None: raise HTTPException( status_code=404, detail=f'user with user_id={user_id} not found' ) user_get = models.UserGet.model_validate(user) return user_get @app.get('/user/', status_code=200, tags=[Tags.user]) def get_current_user( user_db:models.User = Depends(auth.get_current_user) ) -> models.UserGet: user_get = models.UserGet.model_validate(user_db) return user_get @app.get('/user/list/', status_code=200, tags=[Tags.user]) def get_list_of_users( session: Session = Depends(get_session_depends) )-> tp.List[models.UserGet]: query = select(models.User) user_db_list = session.exec(query).all() user_get_list = [ models.UserGet.model_validate(user) for user in user_db_list ] return user_get_list @app.post('/user/', status_code=201, tags=[Tags.user]) def create_user( user: models.UserRegister, session:Session=Depends(get_session_depends) )-> tp.TypedDict('Created message', {'msg': str}): hashed_password = auth.get_password_hash(user.password) user_data = user.dict() user_data['hashed_password'] = hashed_password user = models.User.model_validate(user_data) tools.add_object_to_db_and_refresh(session, user) return {'msg': \"Created\"} @app.put('/user/password/', status_code=201, tags=[Tags.user]) def change_user_password( user_password: models.UserChangePassword, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.TypedDict('password_put_response', {'msg': str}): is_password_correct = auth.verify_password(user_password.current_password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail='Incorrect current password') if user_password.new_password != user_password.new_password_verification: raise HTTPException(status_code=400, detail='Passwords don\\'t match') new_hash = auth.get_password_hash(user_password.new_password) user_db.hashed_password = new_hash session.add(user_db) session.commit() return {'msg': 'password changed'} # ------------Project--------------- @app.get('/project/{project_id}', status_code=200, tags=[Tags.project]) def get_project_info( project_id: int, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> models.ProjectBase: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object project_base = models.ProjectBase.model_validate(project) return project_base @app.get('/project/', status_code=200, tags=[Tags.project]) def get_user_project_list( user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ): statement = select(models.ProjectUserLink) \\ .where(models.ProjectUserLink.user_id == user_db.id) user_entries: tp.List[models.ProjectUserLink] = list(session.exec(statement).all()) return [entry.project for entry in user_entries] @app.post('/project/', status_code=201, tags=[Tags.project]) def create_project( project: models.ProjectBase, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.TypedDict('post_project', {'msg': str}): project = models.Project.model_validate(project) tools.add_object_to_db_and_refresh(session, project) # add creator as project admin link = models.ProjectUserLink( user_id=user_db.id, project_id=project.id, role=models.Role.admin ) tools.add_object_to_db_and_refresh(session, link) return {'msg': 'Created'} @app.get('/project/{project_id}/user/', status_code=200, tags=[Tags.project]) def get_list_of_users_in_project( project_id: int, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.List[models.UserGet]: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object users = project.users users_get = [models.UserGet.model_validate(user) for user in users] return users_get @app.post('/project/{project_id}/user/', status_code=200, tags=[Tags.project]) def add_user_to_project( project_id: int, user_in_project: models.UserInProjectForm, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('add_to_project', {'msg': str}): project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_admin_or_exception() data_for_link = user_in_project.dict() data_for_link['project_id'] = project_id link = models.ProjectUserLink.validate(data_for_link) tools.add_object_to_db_and_refresh(session, link) return {'msg': 'Created'} @app.get('/project/{project_id}/category/', status_code=200, tags=[Tags.project]) def get_project_categories( project_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.List[models.Category]: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object return project.categories @app.post('/project/{project_id}/category/', status_code=201, tags=[Tags.project]) def add_category_to_project( project_id: int, category: models.CategoryBase, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('add_category', {'msg': str, 'object': models.Category}): project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_admin_or_exception() category = category.dict() category['project_id'] = project_id category = models.Category.model_validate(category) tools.add_object_to_db_and_refresh(session, category) return {'msg': 'Created', 'object': category} @app.get('/project/{project_id}/task', status_code=200, tags=[Tags.project]) def get_project_tasks( project_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.List[models.CategoryWithBaseTasks]: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object return project.categories @app.get('/project/{project_id}/calendar_entries', status_code=200, tags=[Tags.project]) def get_project_calendar_entries( project_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.ProjectWithCalendarEntries: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project = project_validator.object project_validator.is_in_project_or_exception() project_with_entries = models.ProjectWithCalendarEntries.model_validate(project) return project_with_entries # -------------------Category--------------- @app.get('/category/{category_id}/', status_code=200, tags=[Tags.category]) def get_category_info( category_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.CategoryBase: category_validator = tools.CategoryValidator(session, user_db.id, category_id) category = category_validator.object category_validator.is_in_project_or_exception() category_base = models.CategoryBase.model_validate(category) return category_base @app.get('/category/{category_id}/task/', status_code=200, tags=[Tags.category]) def get_category_tasks( category_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ): category_validator = tools.CategoryValidator(session, user_db.id, category_id) category = category_validator.object category_validator.is_in_project_or_exception() category_with_tasks = models.CategoryWithBaseTasks.model_validate(category) return category_with_tasks @app.post('/category/{category_id}/task/', status_code=201, tags=[Tags.category]) def add_task_to_category( category_id: int, task: models.TaskBase, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('task added', {'msg': str, 'obj': models.Task}): category_validator = tools.CategoryValidator(session, user_db.id, category_id) category_validator.is_admin_or_exception() task_data = task.dict() task_data['category_id'] = category_id task = models.Task.model_validate(task_data) tools.add_object_to_db_and_refresh(session, task) return {'msg': 'Created', 'obj': task} @app.get('/category/{category_id}/calendar_entries', status_code=200, tags=[Tags.category]) def get_category_calendar_entries( category_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.CategoryWithEntries: category_validator = tools.CategoryValidator(session, user_db.id, category_id) category_validator.is_in_project_or_exception() category = category_validator.object category_with_entries = models.CategoryWithEntries.model_validate( category ) return category_with_entries # ----------------------------Tasks----------------------------- @app.get('/task/{task_id}', status_code=200, tags=[Tags.task]) def get_task_info( task_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.TaskBase: task_validator = tools.TaskValidator(session, user_db.id, task_id) task = task_validator.object task_validator.is_in_project_or_exception() task_base = models.TaskBase.model_validate(task) return task_base @app.post('/task/{task_id}/calendar_entries/', status_code=201, tags=[Tags.task]) def add_calendar_entry_to_task( task_id: int, calendar_entry: models.CalendarEntryBase, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('task added', {'msg': str, 'obj': models.CalendarEntry}): task_validator = tools.TaskValidator(session, user_db.id, task_id) task_validator.is_admin_or_exception() calendar_entry_data = calendar_entry.dict() calendar_entry_data['task_id'] = task_id calendar_entry = models.CalendarEntry.model_validate(calendar_entry_data) tools.add_object_to_db_and_refresh(session, calendar_entry) return {'msg': 'Created', 'obj': calendar_entry} @app.get('/task/{task_id}/calendar_entries/', status_code=200, tags=[Tags.task]) def get_task_calendar_entries( task_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.TaskWithEntries: task_validator = tools.TaskValidator(session, user_db.id, task_id) task = task_validator.object task_validator.is_in_project_or_exception() task_with_entries = models.TaskWithEntries.model_validate(task) return task_with_entries","title":"Endpoints"},{"location":"lab1/endpoints/#endpoints","text":"","title":"Endpoints"},{"location":"lab1/endpoints/#_1","text":"from fastapi import HTTPException import models from sqlmodel import Session, select, SQLModel import typing as tp def add_object_to_db_and_refresh(session: Session, object: SQLModel): session.add(object) session.commit() session.refresh(object) class ProjectValidator: _object = None def __init__(self, session, user_id, object_id): self._session = session self._user_id = user_id self._object_id = object_id self._project = self._retrieve_project() @property def object(self) -> models.Project: if self._object is None: self._object = self._retrieve_object_or_exception() return self._object def _retrieve_project(self) -> models.Project: return self.object def _retrieve_object_or_exception(self) -> models.Project: project = self._session.get(models.Project, self._object_id) if project is None: raise HTTPException( status_code=404, detail=f'Project with id={self.object.id} is not found' ) return project def is_admin_or_exception(self): statement = select(models.ProjectUserLink) \\ .where(models.ProjectUserLink.user_id == self._user_id) \\ .where(models.ProjectUserLink.user_id == self._project.id) user_entries: tp.List[models.ProjectUserLink] = list( self._session.exec(statement).all() ) for entry in user_entries: if entry.role == models.Role.admin: return raise HTTPException( status_code=403, detail=f'you\\'re not admin of project with id={self._project.id}' ) def is_in_project_or_exception(self): statement = select(models.ProjectUserLink) \\ .where(models.ProjectUserLink.user_id == self._user_id) \\ .where(models.ProjectUserLink.user_id == self._project.id) user_entries: tp.List[models.ProjectUserLink] = list(self._session.exec(statement).all()) if len(user_entries) == 0: raise HTTPException( status_code=403, detail=f'You\\'re not allowed to view project with id={self._project.id}' ) class CategoryValidator(ProjectValidator): def _retrieve_project(self) -> models.Project: return self.object.project def _retrieve_object_or_exception(self) -> models.Category: category = self._session.get(models.Category, self._object_id) if category is None: raise HTTPException( status_code=404, detail=f'Category with id={self._object_id} is not found' ) return category class TaskValidator(CategoryValidator): def _retrieve_project(self) -> models.Project: return self.object.category.project def _retrieve_object_or_exception(self) -> models.Task: task = self._session.get(models.Task, self._object_id) if task is None: raise HTTPException( status_code=404, detail=f'Task with id={self._object_id} is not found' ) return task","title":"\u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u044b \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043a\u043e\u043d\u0435\u0447\u043d\u044b\u043c\u0438 \u0442\u043e\u0447\u043a\u0430\u043c\u0438"},{"location":"lab1/endpoints/#_2","text":"from fastapi import FastAPI, Depends, HTTPException import models from sqlmodel import Session, select from db import init_db, get_session_depends import db_queries import auth from enum import Enum import typing as tp from endpoints import endpoint_tools as tools app = FastAPI() class Tags(Enum): user = 'user' project = 'project' category = 'category' task = 'task' @app.on_event(\"startup\") def on_startup(): init_db() # ------------------Token----------------- @app.post('/token/', status_code=200, tags=[Tags.user]) def create_api_token( user_login: models.UserLogin ) -> tp.TypedDict('token_response', {'access_token': str, 'token_type': str}): try: user_db = db_queries.get_user_by_username(user_login.username) except ValueError: raise HTTPException(status_code=400, detail=f'no user with username {user_login.username}') is_password_correct = auth.verify_password(user_login.password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail=f'Incorrect password for username: {user_login.username}') token = auth.generate_token(user_login.username) return {'access_token': token, 'token_type': 'bearer'} # ------------------User------------------- @app.get('/user/{user_id}', status_code=200, tags=[Tags.user]) def get_user_by_id( user_id: int, session: Session = Depends(get_session_depends) ) -> models.UserGet: user = session.get(models.User, user_id) if user is None: raise HTTPException( status_code=404, detail=f'user with user_id={user_id} not found' ) user_get = models.UserGet.model_validate(user) return user_get @app.get('/user/', status_code=200, tags=[Tags.user]) def get_current_user( user_db:models.User = Depends(auth.get_current_user) ) -> models.UserGet: user_get = models.UserGet.model_validate(user_db) return user_get @app.get('/user/list/', status_code=200, tags=[Tags.user]) def get_list_of_users( session: Session = Depends(get_session_depends) )-> tp.List[models.UserGet]: query = select(models.User) user_db_list = session.exec(query).all() user_get_list = [ models.UserGet.model_validate(user) for user in user_db_list ] return user_get_list @app.post('/user/', status_code=201, tags=[Tags.user]) def create_user( user: models.UserRegister, session:Session=Depends(get_session_depends) )-> tp.TypedDict('Created message', {'msg': str}): hashed_password = auth.get_password_hash(user.password) user_data = user.dict() user_data['hashed_password'] = hashed_password user = models.User.model_validate(user_data) tools.add_object_to_db_and_refresh(session, user) return {'msg': \"Created\"} @app.put('/user/password/', status_code=201, tags=[Tags.user]) def change_user_password( user_password: models.UserChangePassword, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.TypedDict('password_put_response', {'msg': str}): is_password_correct = auth.verify_password(user_password.current_password, user_db.hashed_password) if not is_password_correct: raise HTTPException(status_code=400, detail='Incorrect current password') if user_password.new_password != user_password.new_password_verification: raise HTTPException(status_code=400, detail='Passwords don\\'t match') new_hash = auth.get_password_hash(user_password.new_password) user_db.hashed_password = new_hash session.add(user_db) session.commit() return {'msg': 'password changed'} # ------------Project--------------- @app.get('/project/{project_id}', status_code=200, tags=[Tags.project]) def get_project_info( project_id: int, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> models.ProjectBase: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object project_base = models.ProjectBase.model_validate(project) return project_base @app.get('/project/', status_code=200, tags=[Tags.project]) def get_user_project_list( user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ): statement = select(models.ProjectUserLink) \\ .where(models.ProjectUserLink.user_id == user_db.id) user_entries: tp.List[models.ProjectUserLink] = list(session.exec(statement).all()) return [entry.project for entry in user_entries] @app.post('/project/', status_code=201, tags=[Tags.project]) def create_project( project: models.ProjectBase, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.TypedDict('post_project', {'msg': str}): project = models.Project.model_validate(project) tools.add_object_to_db_and_refresh(session, project) # add creator as project admin link = models.ProjectUserLink( user_id=user_db.id, project_id=project.id, role=models.Role.admin ) tools.add_object_to_db_and_refresh(session, link) return {'msg': 'Created'} @app.get('/project/{project_id}/user/', status_code=200, tags=[Tags.project]) def get_list_of_users_in_project( project_id: int, user_db: models.User = Depends(auth.get_current_user), session: Session = Depends(get_session_depends) ) -> tp.List[models.UserGet]: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object users = project.users users_get = [models.UserGet.model_validate(user) for user in users] return users_get @app.post('/project/{project_id}/user/', status_code=200, tags=[Tags.project]) def add_user_to_project( project_id: int, user_in_project: models.UserInProjectForm, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('add_to_project', {'msg': str}): project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_admin_or_exception() data_for_link = user_in_project.dict() data_for_link['project_id'] = project_id link = models.ProjectUserLink.validate(data_for_link) tools.add_object_to_db_and_refresh(session, link) return {'msg': 'Created'} @app.get('/project/{project_id}/category/', status_code=200, tags=[Tags.project]) def get_project_categories( project_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.List[models.Category]: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object return project.categories @app.post('/project/{project_id}/category/', status_code=201, tags=[Tags.project]) def add_category_to_project( project_id: int, category: models.CategoryBase, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('add_category', {'msg': str, 'object': models.Category}): project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_admin_or_exception() category = category.dict() category['project_id'] = project_id category = models.Category.model_validate(category) tools.add_object_to_db_and_refresh(session, category) return {'msg': 'Created', 'object': category} @app.get('/project/{project_id}/task', status_code=200, tags=[Tags.project]) def get_project_tasks( project_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.List[models.CategoryWithBaseTasks]: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project_validator.is_in_project_or_exception() project = project_validator.object return project.categories @app.get('/project/{project_id}/calendar_entries', status_code=200, tags=[Tags.project]) def get_project_calendar_entries( project_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.ProjectWithCalendarEntries: project_validator = tools.ProjectValidator(session, user_db.id, project_id) project = project_validator.object project_validator.is_in_project_or_exception() project_with_entries = models.ProjectWithCalendarEntries.model_validate(project) return project_with_entries # -------------------Category--------------- @app.get('/category/{category_id}/', status_code=200, tags=[Tags.category]) def get_category_info( category_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.CategoryBase: category_validator = tools.CategoryValidator(session, user_db.id, category_id) category = category_validator.object category_validator.is_in_project_or_exception() category_base = models.CategoryBase.model_validate(category) return category_base @app.get('/category/{category_id}/task/', status_code=200, tags=[Tags.category]) def get_category_tasks( category_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ): category_validator = tools.CategoryValidator(session, user_db.id, category_id) category = category_validator.object category_validator.is_in_project_or_exception() category_with_tasks = models.CategoryWithBaseTasks.model_validate(category) return category_with_tasks @app.post('/category/{category_id}/task/', status_code=201, tags=[Tags.category]) def add_task_to_category( category_id: int, task: models.TaskBase, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('task added', {'msg': str, 'obj': models.Task}): category_validator = tools.CategoryValidator(session, user_db.id, category_id) category_validator.is_admin_or_exception() task_data = task.dict() task_data['category_id'] = category_id task = models.Task.model_validate(task_data) tools.add_object_to_db_and_refresh(session, task) return {'msg': 'Created', 'obj': task} @app.get('/category/{category_id}/calendar_entries', status_code=200, tags=[Tags.category]) def get_category_calendar_entries( category_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.CategoryWithEntries: category_validator = tools.CategoryValidator(session, user_db.id, category_id) category_validator.is_in_project_or_exception() category = category_validator.object category_with_entries = models.CategoryWithEntries.model_validate( category ) return category_with_entries # ----------------------------Tasks----------------------------- @app.get('/task/{task_id}', status_code=200, tags=[Tags.task]) def get_task_info( task_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.TaskBase: task_validator = tools.TaskValidator(session, user_db.id, task_id) task = task_validator.object task_validator.is_in_project_or_exception() task_base = models.TaskBase.model_validate(task) return task_base @app.post('/task/{task_id}/calendar_entries/', status_code=201, tags=[Tags.task]) def add_calendar_entry_to_task( task_id: int, calendar_entry: models.CalendarEntryBase, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> tp.TypedDict('task added', {'msg': str, 'obj': models.CalendarEntry}): task_validator = tools.TaskValidator(session, user_db.id, task_id) task_validator.is_admin_or_exception() calendar_entry_data = calendar_entry.dict() calendar_entry_data['task_id'] = task_id calendar_entry = models.CalendarEntry.model_validate(calendar_entry_data) tools.add_object_to_db_and_refresh(session, calendar_entry) return {'msg': 'Created', 'obj': calendar_entry} @app.get('/task/{task_id}/calendar_entries/', status_code=200, tags=[Tags.task]) def get_task_calendar_entries( task_id: int, session: Session = Depends(get_session_depends), user_db: models.User = Depends(auth.get_current_user) ) -> models.TaskWithEntries: task_validator = tools.TaskValidator(session, user_db.id, task_id) task = task_validator.object task_validator.is_in_project_or_exception() task_with_entries = models.TaskWithEntries.model_validate(task) return task_with_entries","title":"\u041a\u043e\u043d\u0435\u0447\u043d\u044b\u0435 \u0442\u043e\u0447\u043a\u0438"},{"location":"lab1/models/","text":"\u041c\u043e\u0434\u0435\u043b\u0438 \u0421\u0445\u0435\u043c\u0430 \u0411\u0414 \u041a\u043e\u0434 \u0434\u043b\u044f \u043c\u043e\u0434\u0435\u043b\u0435\u0439 from sqlmodel import SQLModel,Field, select, Relationship import pydantic from db import get_session_func from enum import Enum from typing import Optional, Type, List import datetime def is_in_table(model: Type[SQLModel], field, unique_value): with get_session_func() as session: statement = select(model).where(field == unique_value) result = list(session.exec(statement)) return len(result) > 0 class Role(Enum): admin = 'admin' viewer = 'viewer' class Priority(Enum): low = 0 medium = 1 high = 2 class ProjectUserLink(SQLModel, table=True): id: int = Field(default=None, primary_key=True) user_id: int = Field(foreign_key='user.id') user: 'User' = Relationship() project_id: int = Field(foreign_key='project.id') project: 'Project' = Relationship() role: Role class UserInProjectForm(SQLModel): user_id: int role: Role class UserSuperBase(SQLModel): username: str = Field(unique=True) email: str @pydantic.field_validator('email') @classmethod def validate_email(cls, value: str) -> str: pydantic.EmailStr._validate(value) return value @pydantic.field_validator('username') @classmethod def validate_username(cls, value: str) -> str: if is_in_table(User, User.username, value): raise ValueError('username is not unique') return value class UserBase(UserSuperBase): hashed_password: str class UserRegister(UserSuperBase): password: str class UserLogin(SQLModel): username: str password: str class UserGet(SQLModel): username: str email: str class UserChangePassword(SQLModel): current_password: str new_password: str new_password_verification: str class User(UserBase, table=True): id: int = Field(default=None, primary_key=True) projects: List['Project'] = Relationship(back_populates='users', link_model=ProjectUserLink) class ProjectBase(SQLModel): title: str description: Optional[str] class Project(ProjectBase, table=True): id: int = Field(default=None, primary_key=True) users: List[User] = Relationship(back_populates='projects', link_model=ProjectUserLink) categories: List['Category'] = Relationship(back_populates='project') class ProjectWithCalendarEntries(ProjectBase): categories: List['CategoryWithEntries'] class CategoryBase(SQLModel): title: str description: Optional[str] class Category(CategoryBase, table=True): id: int = Field(default=None, primary_key=True) # \u043e\u0442\u0432\u0435\u0447\u0430\u0435\u0442 \u0437\u0430 \u0440\u0435\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u043e\u043b\u0435 \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 project_id: int = Field(foreign_key='project.id') # \u043e\u0442\u0432\u0435\u0447\u0430\u0435\u0442 \u0437\u0430 category.project \u0438 project.categories project: Project = Relationship(back_populates='categories') tasks: List['Task'] = Relationship(back_populates='category') class CategoryWithBaseTasks(CategoryBase): tasks: List['TaskBase'] class CategoryWithEntries(CategoryBase): tasks: List['TaskWithEntries'] class TaskBase(SQLModel): title: str description: Optional[str] deadline: Optional[int] priority: Priority approximate_time: datetime.time class Task(TaskBase, table=True): id: int = Field(default=None, primary_key=True) category_id: int = Field(foreign_key='category.id') category: Category = Relationship(back_populates='tasks') calendar_entries: List['CalendarEntry'] = Relationship(back_populates='task') class TaskGet(TaskBase): Category: Category class CalendarEntryBase(SQLModel): start_time: datetime.datetime end_time: datetime.datetime class CalendarEntry(CalendarEntryBase, table=True): id: int = Field(default=None, primary_key=True) task_id: int = Field(foreign_key='task.id') task: Task = Relationship(back_populates='calendar_entries') class CalendarEntryWithId(CalendarEntryBase): id: int class TaskWithEntries(TaskBase): calendar_entries: List[CalendarEntryWithId]","title":"\u041c\u043e\u0434\u0435\u043b\u0438"},{"location":"lab1/models/#_1","text":"","title":"\u041c\u043e\u0434\u0435\u043b\u0438"},{"location":"lab1/models/#_2","text":"","title":"\u0421\u0445\u0435\u043c\u0430 \u0411\u0414"},{"location":"lab1/models/#_3","text":"from sqlmodel import SQLModel,Field, select, Relationship import pydantic from db import get_session_func from enum import Enum from typing import Optional, Type, List import datetime def is_in_table(model: Type[SQLModel], field, unique_value): with get_session_func() as session: statement = select(model).where(field == unique_value) result = list(session.exec(statement)) return len(result) > 0 class Role(Enum): admin = 'admin' viewer = 'viewer' class Priority(Enum): low = 0 medium = 1 high = 2 class ProjectUserLink(SQLModel, table=True): id: int = Field(default=None, primary_key=True) user_id: int = Field(foreign_key='user.id') user: 'User' = Relationship() project_id: int = Field(foreign_key='project.id') project: 'Project' = Relationship() role: Role class UserInProjectForm(SQLModel): user_id: int role: Role class UserSuperBase(SQLModel): username: str = Field(unique=True) email: str @pydantic.field_validator('email') @classmethod def validate_email(cls, value: str) -> str: pydantic.EmailStr._validate(value) return value @pydantic.field_validator('username') @classmethod def validate_username(cls, value: str) -> str: if is_in_table(User, User.username, value): raise ValueError('username is not unique') return value class UserBase(UserSuperBase): hashed_password: str class UserRegister(UserSuperBase): password: str class UserLogin(SQLModel): username: str password: str class UserGet(SQLModel): username: str email: str class UserChangePassword(SQLModel): current_password: str new_password: str new_password_verification: str class User(UserBase, table=True): id: int = Field(default=None, primary_key=True) projects: List['Project'] = Relationship(back_populates='users', link_model=ProjectUserLink) class ProjectBase(SQLModel): title: str description: Optional[str] class Project(ProjectBase, table=True): id: int = Field(default=None, primary_key=True) users: List[User] = Relationship(back_populates='projects', link_model=ProjectUserLink) categories: List['Category'] = Relationship(back_populates='project') class ProjectWithCalendarEntries(ProjectBase): categories: List['CategoryWithEntries'] class CategoryBase(SQLModel): title: str description: Optional[str] class Category(CategoryBase, table=True): id: int = Field(default=None, primary_key=True) # \u043e\u0442\u0432\u0435\u0447\u0430\u0435\u0442 \u0437\u0430 \u0440\u0435\u0430\u043b\u044c\u043d\u043e\u0435 \u043f\u043e\u043b\u0435 \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 project_id: int = Field(foreign_key='project.id') # \u043e\u0442\u0432\u0435\u0447\u0430\u0435\u0442 \u0437\u0430 category.project \u0438 project.categories project: Project = Relationship(back_populates='categories') tasks: List['Task'] = Relationship(back_populates='category') class CategoryWithBaseTasks(CategoryBase): tasks: List['TaskBase'] class CategoryWithEntries(CategoryBase): tasks: List['TaskWithEntries'] class TaskBase(SQLModel): title: str description: Optional[str] deadline: Optional[int] priority: Priority approximate_time: datetime.time class Task(TaskBase, table=True): id: int = Field(default=None, primary_key=True) category_id: int = Field(foreign_key='category.id') category: Category = Relationship(back_populates='tasks') calendar_entries: List['CalendarEntry'] = Relationship(back_populates='task') class TaskGet(TaskBase): Category: Category class CalendarEntryBase(SQLModel): start_time: datetime.datetime end_time: datetime.datetime class CalendarEntry(CalendarEntryBase, table=True): id: int = Field(default=None, primary_key=True) task_id: int = Field(foreign_key='task.id') task: Task = Relationship(back_populates='calendar_entries') class CalendarEntryWithId(CalendarEntryBase): id: int class TaskWithEntries(TaskBase): calendar_entries: List[CalendarEntryWithId]","title":"\u041a\u043e\u0434 \u0434\u043b\u044f \u043c\u043e\u0434\u0435\u043b\u0435\u0439"},{"location":"lab1/practice/","text":"\u041f\u0440\u0430\u043a\u0442\u0438\u043a\u0430 \u041f\u0440\u0430\u043a\u0442\u0438\u043a\u0430 1 - \u0441\u0441\u044b\u043b\u043a\u0430 \u041f\u0440\u0430\u043a\u0442\u0438\u043a\u0430 2/3 - \u0441\u0441\u044b\u043b\u043a\u0430","title":"\u041f\u0440\u0430\u043a\u0442\u0438\u043a\u0430"},{"location":"lab1/practice/#_1","text":"\u041f\u0440\u0430\u043a\u0442\u0438\u043a\u0430 1 - \u0441\u0441\u044b\u043b\u043a\u0430 \u041f\u0440\u0430\u043a\u0442\u0438\u043a\u0430 2/3 - \u0441\u0441\u044b\u043b\u043a\u0430","title":"\u041f\u0440\u0430\u043a\u0442\u0438\u043a\u0430"},{"location":"lab2/task1/","text":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1 \u0420\u0435\u043b\u0430\u0437\u0438\u0430\u0446\u0438\u044f \u043d\u0430 asyncIO \u041a\u043e\u0434: import asyncio import math import time async def compute_sum(start, end): return sum(range(start, end + 1)) async def compute_with_threading(start, end, n_funcs): coroutines = [] step = int(math.ceil((end - start) / n_funcs)) start_i = start while start_i <= end: end_i = min(start_i + step, end) coroutine = compute_sum(start_i, end_i) coroutines.append(coroutine) start_i = end_i + 1 gather_coroutine = asyncio.gather(*coroutines) partial_sums = await gather_coroutine result_sum = sum(partial_sums) return result_sum async def measure(n_funcs): start_time = time.perf_counter() res = await compute_with_threading(1, 1000000, n_funcs) elapsed = round(time.perf_counter() - start_time, 4) print(f\"Async functions: {n_funcs}; time: {elapsed}; result: {res}\") async def main(): n_funcs_list = [1, 5, 10, 20, 50, 100, 1000] for n_funcs in n_funcs_list: await measure(n_funcs) if __name__ == \"__main__\": asyncio.run(main()) \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442: Async functions: 1; time: 0.0793; result: 500000500000 Async functions: 5; time: 0.067; result: 500000500000 Async functions: 10; time: 0.1418; result: 500000500000 Async functions: 20; time: 0.0961; result: 500000500000 Async functions: 50; time: 0.1274; result: 500000500000 Async functions: 100; time: 0.1254; result: 500000500000 Async functions: 1000; time: 0.0747; result: 500000500000 \u0412\u044b\u0432\u043e\u0434: \u0412\u0438\u0434\u0438\u043c, \u0447\u0442\u043e \u0443\u0432\u0435\u043b\u0438\u0447\u0435\u043d\u0438\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u043d\u0435 \u043f\u0440\u0438\u0432\u043e\u0434\u0438\u0442 \u043a \u043f\u0440\u0438\u0440\u043e\u0441\u0442\u0443 \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u0438, \u043f\u043e\u0442\u043e\u043c\u0443 \u0447\u0442\u043e \u0432 \u043d\u0430\u0448\u0435\u0439 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0435 \u043d\u0435\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439 \u0441 \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u0435\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442, \u0432\u043e\u043f\u0440\u043e\u0441 \u0437\u0430\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u0432 \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u0438 \u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043d\u0430 threading \u041a\u043e\u0434: from concurrent.futures import ThreadPoolExecutor import threading import time import math result = 0 result_lock = threading.Lock() def compute_sum(start, end): global result sm = sum(range(start, end+1)) result_lock.acquire() result += sm result_lock.release() def compute_with_threading(start, end, n_threads): global result result = 0 with ThreadPoolExecutor() as executor: step = int(math.ceil((end - start) / n_threads)) start_i = start while start_i <= end: end_i = min(start_i + step, end) executor.submit(compute_sum, start_i, end_i) start_i = end_i + 1 return result def measure(n_threads): start_time = time.perf_counter() res = compute_with_threading(1, 1000000, n_threads) elapsed = round(time.perf_counter() - start_time, 4) print(f\"Threads: {n_threads}; time: {elapsed}; result: {res}\") if __name__ == \"__main__\": n_threads_list = [1, 5, 10, 20, 50, 100] for n_threads in n_threads_list: measure(n_threads) \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442: Threads: 1; time: 0.0827; result: 500000500000 Threads: 5; time: 0.0713; result: 500000500000 Threads: 10; time: 0.0787; result: 500000500000 Threads: 20; time: 0.0807; result: 500000500000 Threads: 50; time: 0.0717; result: 500000500000 Threads: 100; time: 0.0668; result: 500000500000 \u0412\u044b\u0432\u043e\u0434: \u0412\u0438\u0434\u0438\u043c, \u0447\u0442\u043e \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043f\u0440\u0438\u043c\u0435\u0440\u043d\u043e \u0440\u0430\u0432\u0435\u043d AsyncIO \u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043d\u0430 multiprocessing \u0447\u0435\u0440\u0435\u0437 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0412 \u0434\u0430\u043d\u043d\u043e\u0439 \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0438 \u0434\u0430\u043d\u043d\u044b\u0445 \u043c\u0435\u0436\u0434\u0443 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\u043c\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043b\u043e\u0441\u044c multiprocessing.Value \u041a\u043e\u0434: import multiprocessing import time import math def compute_sum(start, end, res_value): sm = sum(range(start, end + 1)) res_value.acquire() res_value.value += sm res_value.release() def compute_with_threading(start, end, n_threads): processes = [] values = [] step = int(math.ceil((end - start) / n_threads)) start_i = start value = multiprocessing.Value(\"q\", 0) while start_i <= end: end_i = min(start_i + step, end) process = multiprocessing.Process( target=compute_sum, args=[start_i, end_i, value] ) process.start() processes.append(process) start_i = end_i + 1 for process in processes: process.join() return value.value def measure(n_threads): start_time = time.perf_counter() res = compute_with_threading(1, 1000_000, n_threads) elapsed = round(time.perf_counter() - start_time, 4) print(f\"Processes: {n_threads}; time: {elapsed}; result: {res}\") if __name__ == \"__main__\": n_threads_list = [1, 2, 5, 10] for n_threads in n_threads_list: measure(n_threads) \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442: Processes: 1; time: 0.2716; result: 500000500000 Processes: 2; time: 0.2046; result: 500000500000 Processes: 5; time: 0.2634; result: 500000500000 Processes: 10; time: 0.4576; result: 500000500000 Processes: 30; time: 0.9976; result: 500000500000 \u0412\u044b\u0432\u043e\u0434: \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u0443\u044e \u043a\u0430\u0440\u0442\u0438\u043d\u0443 \u043d\u0430 2-5 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\u0445, \u0430 \u043f\u0440\u0438 \u0443\u0432\u0435\u043b\u0438\u0447\u0435\u043d\u0438\u0438 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u043f\u0430\u0434\u0430\u0435\u0442. \u042d\u0442\u043e \u0441\u0432\u044f\u0437\u0430\u043d\u043e \u0441 \u0442\u0435\u043c, \u0447\u0442\u043e \u0437\u0430\u0442\u0440\u0430\u0442\u044b \u043d\u0430 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432 \u043d\u0435 \u043e\u043a\u0443\u043f\u0430\u044e\u0442 \u043f\u0440\u0438\u0440\u043e\u0441\u0442 \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u0438 \u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043d\u0430 multiprocessing \u0447\u0435\u0440\u0435\u0437 \u043e\u0447\u0435\u0440\u0435\u0434\u044c \u041a\u043e\u0434: import multiprocessing import time import math def compute_sum(start, end, queue): sm = sum(range(start, end + 1)) queue.put(sm) def compute_with_threading(start, end, n_threads): processes = [] step = int(math.ceil((end - start) / n_threads)) start_i = start queue = multiprocessing.Queue() while start_i <= end: end_i = min(start_i + step, end) process = multiprocessing.Process( target=compute_sum, args=[start_i, end_i, queue] ) process.start() processes.append(process) start_i = end_i + 1 for process in processes: process.join() result = 0 while not queue.empty(): result += queue.get() return result def measure(n_threads): start_time = time.perf_counter() res = compute_with_threading(1, 1000000, n_threads) elapsed = round(time.perf_counter() - start_time, 4) print(f\"Processes: {n_threads}; time: {elapsed}; result: {res}\") if __name__ == \"__main__\": n_threads_list = [1, 2, 5, 10, 30] for n_threads in n_threads_list: measure(n_threads) \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442: Processes: 1; time: 0.2835; result: 500000500000 Processes: 2; time: 0.1856; result: 500000500000 Processes: 5; time: 0.2023; result: 500000500000 Processes: 10; time: 0.3622; result: 500000500000 Processes: 30; time: 1.0166; result: 500000500000 \u0412\u044b\u0432\u043e\u0434: \u0420\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0447\u0443\u0442\u044c \u0431\u044b\u0441\u0442\u0440\u0435\u0435, \u043b\u0443\u0448\u0447\u0435 \u0432\u0441\u0435\u0433\u043e \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u043f\u0440\u0438 2-5 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\u0445 \u0412\u044b\u0432\u043e\u0434 AsyncIO \u0438 threadin \u0440\u0430\u0431\u043e\u0442\u0430\u044e\u0442 \u043f\u0440\u0438\u043c\u0435\u0440\u043d\u043e \u0441 \u043e\u0434\u043d\u043e\u0439 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c\u044e. Multiprocessing \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0447\u0443\u0442\u044c \u043c\u0435\u0434\u043b\u0435\u043d\u043d\u0435\u0435, \u0432\u0438\u0434\u0438\u043c\u043e \u043f\u043e\u0442\u043e\u043c\u0443 \u0447\u0442\u043e \u0437\u0430\u0442\u0440\u0430\u0442\u044b \u043d\u0430 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432 \u043d\u0438\u0436\u0435 \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u0438, \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043c\u044b \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0441 \u044d\u0442\u043e\u0433\u043e","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1"},{"location":"lab2/task1/#1","text":"","title":"\u0417\u0430\u0434\u0430\u043d\u0438\u0435 1"},{"location":"lab2/task1/#asyncio","text":"\u041a\u043e\u0434: import asyncio import math import time async def compute_sum(start, end): return sum(range(start, end + 1)) async def compute_with_threading(start, end, n_funcs): coroutines = [] step = int(math.ceil((end - start) / n_funcs)) start_i = start while start_i <= end: end_i = min(start_i + step, end) coroutine = compute_sum(start_i, end_i) coroutines.append(coroutine) start_i = end_i + 1 gather_coroutine = asyncio.gather(*coroutines) partial_sums = await gather_coroutine result_sum = sum(partial_sums) return result_sum async def measure(n_funcs): start_time = time.perf_counter() res = await compute_with_threading(1, 1000000, n_funcs) elapsed = round(time.perf_counter() - start_time, 4) print(f\"Async functions: {n_funcs}; time: {elapsed}; result: {res}\") async def main(): n_funcs_list = [1, 5, 10, 20, 50, 100, 1000] for n_funcs in n_funcs_list: await measure(n_funcs) if __name__ == \"__main__\": asyncio.run(main()) \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442: Async functions: 1; time: 0.0793; result: 500000500000 Async functions: 5; time: 0.067; result: 500000500000 Async functions: 10; time: 0.1418; result: 500000500000 Async functions: 20; time: 0.0961; result: 500000500000 Async functions: 50; time: 0.1274; result: 500000500000 Async functions: 100; time: 0.1254; result: 500000500000 Async functions: 1000; time: 0.0747; result: 500000500000 \u0412\u044b\u0432\u043e\u0434: \u0412\u0438\u0434\u0438\u043c, \u0447\u0442\u043e \u0443\u0432\u0435\u043b\u0438\u0447\u0435\u043d\u0438\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u043d\u0435 \u043f\u0440\u0438\u0432\u043e\u0434\u0438\u0442 \u043a \u043f\u0440\u0438\u0440\u043e\u0441\u0442\u0443 \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u0438, \u043f\u043e\u0442\u043e\u043c\u0443 \u0447\u0442\u043e \u0432 \u043d\u0430\u0448\u0435\u0439 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0435 \u043d\u0435\u0442 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439 \u0441 \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u0435\u043c \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442, \u0432\u043e\u043f\u0440\u043e\u0441 \u0437\u0430\u043a\u043b\u044e\u0447\u0430\u0435\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u0432 \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u0438","title":"\u0420\u0435\u043b\u0430\u0437\u0438\u0430\u0446\u0438\u044f \u043d\u0430 asyncIO"},{"location":"lab2/task1/#threading","text":"\u041a\u043e\u0434: from concurrent.futures import ThreadPoolExecutor import threading import time import math result = 0 result_lock = threading.Lock() def compute_sum(start, end): global result sm = sum(range(start, end+1)) result_lock.acquire() result += sm result_lock.release() def compute_with_threading(start, end, n_threads): global result result = 0 with ThreadPoolExecutor() as executor: step = int(math.ceil((end - start) / n_threads)) start_i = start while start_i <= end: end_i = min(start_i + step, end) executor.submit(compute_sum, start_i, end_i) start_i = end_i + 1 return result def measure(n_threads): start_time = time.perf_counter() res = compute_with_threading(1, 1000000, n_threads) elapsed = round(time.perf_counter() - start_time, 4) print(f\"Threads: {n_threads}; time: {elapsed}; result: {res}\") if __name__ == \"__main__\": n_threads_list = [1, 5, 10, 20, 50, 100] for n_threads in n_threads_list: measure(n_threads) \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442: Threads: 1; time: 0.0827; result: 500000500000 Threads: 5; time: 0.0713; result: 500000500000 Threads: 10; time: 0.0787; result: 500000500000 Threads: 20; time: 0.0807; result: 500000500000 Threads: 50; time: 0.0717; result: 500000500000 Threads: 100; time: 0.0668; result: 500000500000 \u0412\u044b\u0432\u043e\u0434: \u0412\u0438\u0434\u0438\u043c, \u0447\u0442\u043e \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043f\u0440\u0438\u043c\u0435\u0440\u043d\u043e \u0440\u0430\u0432\u0435\u043d AsyncIO","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043d\u0430 threading"},{"location":"lab2/task1/#multiprocessing","text":"\u0412 \u0434\u0430\u043d\u043d\u043e\u0439 \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0434\u0430\u0447\u0438 \u0434\u0430\u043d\u043d\u044b\u0445 \u043c\u0435\u0436\u0434\u0443 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\u043c\u0438 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043b\u043e\u0441\u044c multiprocessing.Value \u041a\u043e\u0434: import multiprocessing import time import math def compute_sum(start, end, res_value): sm = sum(range(start, end + 1)) res_value.acquire() res_value.value += sm res_value.release() def compute_with_threading(start, end, n_threads): processes = [] values = [] step = int(math.ceil((end - start) / n_threads)) start_i = start value = multiprocessing.Value(\"q\", 0) while start_i <= end: end_i = min(start_i + step, end) process = multiprocessing.Process( target=compute_sum, args=[start_i, end_i, value] ) process.start() processes.append(process) start_i = end_i + 1 for process in processes: process.join() return value.value def measure(n_threads): start_time = time.perf_counter() res = compute_with_threading(1, 1000_000, n_threads) elapsed = round(time.perf_counter() - start_time, 4) print(f\"Processes: {n_threads}; time: {elapsed}; result: {res}\") if __name__ == \"__main__\": n_threads_list = [1, 2, 5, 10] for n_threads in n_threads_list: measure(n_threads) \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442: Processes: 1; time: 0.2716; result: 500000500000 Processes: 2; time: 0.2046; result: 500000500000 Processes: 5; time: 0.2634; result: 500000500000 Processes: 10; time: 0.4576; result: 500000500000 Processes: 30; time: 0.9976; result: 500000500000 \u0412\u044b\u0432\u043e\u0434: \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043e\u043f\u0442\u0438\u043c\u0430\u043b\u044c\u043d\u0443\u044e \u043a\u0430\u0440\u0442\u0438\u043d\u0443 \u043d\u0430 2-5 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\u0445, \u0430 \u043f\u0440\u0438 \u0443\u0432\u0435\u043b\u0438\u0447\u0435\u043d\u0438\u0438 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u043f\u0430\u0434\u0430\u0435\u0442. \u042d\u0442\u043e \u0441\u0432\u044f\u0437\u0430\u043d\u043e \u0441 \u0442\u0435\u043c, \u0447\u0442\u043e \u0437\u0430\u0442\u0440\u0430\u0442\u044b \u043d\u0430 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432 \u043d\u0435 \u043e\u043a\u0443\u043f\u0430\u044e\u0442 \u043f\u0440\u0438\u0440\u043e\u0441\u0442 \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u0438","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043d\u0430 multiprocessing \u0447\u0435\u0440\u0435\u0437 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435"},{"location":"lab2/task1/#multiprocessing_1","text":"\u041a\u043e\u0434: import multiprocessing import time import math def compute_sum(start, end, queue): sm = sum(range(start, end + 1)) queue.put(sm) def compute_with_threading(start, end, n_threads): processes = [] step = int(math.ceil((end - start) / n_threads)) start_i = start queue = multiprocessing.Queue() while start_i <= end: end_i = min(start_i + step, end) process = multiprocessing.Process( target=compute_sum, args=[start_i, end_i, queue] ) process.start() processes.append(process) start_i = end_i + 1 for process in processes: process.join() result = 0 while not queue.empty(): result += queue.get() return result def measure(n_threads): start_time = time.perf_counter() res = compute_with_threading(1, 1000000, n_threads) elapsed = round(time.perf_counter() - start_time, 4) print(f\"Processes: {n_threads}; time: {elapsed}; result: {res}\") if __name__ == \"__main__\": n_threads_list = [1, 2, 5, 10, 30] for n_threads in n_threads_list: measure(n_threads) \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442: Processes: 1; time: 0.2835; result: 500000500000 Processes: 2; time: 0.1856; result: 500000500000 Processes: 5; time: 0.2023; result: 500000500000 Processes: 10; time: 0.3622; result: 500000500000 Processes: 30; time: 1.0166; result: 500000500000 \u0412\u044b\u0432\u043e\u0434: \u0420\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0447\u0443\u0442\u044c \u0431\u044b\u0441\u0442\u0440\u0435\u0435, \u043b\u0443\u0448\u0447\u0435 \u0432\u0441\u0435\u0433\u043e \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u043f\u0440\u0438 2-5 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430\u0445","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043d\u0430 multiprocessing \u0447\u0435\u0440\u0435\u0437 \u043e\u0447\u0435\u0440\u0435\u0434\u044c"},{"location":"lab2/task1/#_1","text":"AsyncIO \u0438 threadin \u0440\u0430\u0431\u043e\u0442\u0430\u044e\u0442 \u043f\u0440\u0438\u043c\u0435\u0440\u043d\u043e \u0441 \u043e\u0434\u043d\u043e\u0439 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c\u044e. Multiprocessing \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0447\u0443\u0442\u044c \u043c\u0435\u0434\u043b\u0435\u043d\u043d\u0435\u0435, \u0432\u0438\u0434\u0438\u043c\u043e \u043f\u043e\u0442\u043e\u043c\u0443 \u0447\u0442\u043e \u0437\u0430\u0442\u0440\u0430\u0442\u044b \u043d\u0430 \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u043e\u0432 \u043d\u0438\u0436\u0435 \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0439 \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u0438, \u043a\u043e\u0442\u043e\u0440\u0443\u044e \u043c\u044b \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0441 \u044d\u0442\u043e\u0433\u043e","title":"\u0412\u044b\u0432\u043e\u0434"},{"location":"lab2/task2_asyncio/","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0447\u0435\u0440\u0435\u0437 AsyncIO \u041a\u043e\u0434: from dotenv import dotenv_values from pathlib import Path from notion_client import AsyncClient from dataclasses import dataclass from datetime import datetime import models from sqlalchemy import select from db_connection import get_session_context import asyncio import requests from elapsed_logging import logger from uuid import UUID exercise2_path = Path(__file__).parent.parent env_path = exercise2_path / \".env\" config = dotenv_values(env_path) notion_secret = config[\"notion_secret\"] db_id = \"7401d3f130414235ab1abb429d41a31e\" headers = { \"Authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NjM0NTQ4NzUsImlhdCI6MTcxNTQ1NDg3NSwic3ViIjoidXNlcjEifQ.u4I3i-utbj3gwwlLc9ABIfvKneg-Ri3VzZVkmoNh-Wc\" } notion = AsyncClient(auth=notion_secret) async def get_task_pages(db_id: str): \"\"\"\u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u0432\u0441\u0435 id \u0441\u0442\u0440\u0430\u043d\u0438\u0446, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043d\u0430\u0445\u043e\u0434\u044f\u0442\u0441\u044f \u0432 \u0411\u0414 Args: db_id (str): id \u0411\u0414 \u0432 notion Returns: list[str]: \u0421\u043f\u0438\u0441\u043e\u043a id \u0441\u0442\u0440\u0430\u043d\u0438\u0446 \"\"\" response = await notion.databases.query(db_id) entries_list = response[\"results\"] page_ids = [] for entry in entries_list: if entry[\"object\"] == \"page\": page_id = entry[\"id\"] page_ids.append(page_id) return page_ids class TaskParser: def __init__(self, task_notion: dict) -> None: self.task_notion = task_notion def get_title(self) -> str | None: title_list = self.get_value_or_none( self.task_notion, [\"Name\", \"title\"] ) if len(title_list) == 0: return None title_object = title_list[0] title = self.get_value_or_none( title_object, ['plain_text'] ) return title def get_category_title(self) -> str | None: title = self.get_value_or_none( self.task_notion, (\"Tasks\", \"select\", \"name\") ) return title def get_description(self) -> str | None: return None def get_deadline(self) -> str | None: deadline = self.get_value_or_none( self.task_notion, (\"due\", \"date\", \"start\") ) return deadline def get_priority(self) -> models.Priority | None: urgent_flag = self.get_value_or_none( self.task_notion, ['Urgent', 'checkbox'] ) if urgent_flag: return models.Priority.high return models.Priority.low def get_approximate_time(self) -> int | None: approximate_time = self.get_value_or_none( self.task_notion, [\"Aproximate time\", 'number'] ) if approximate_time is not None: approximate_time = int(approximate_time) return approximate_time @staticmethod def get_value_or_none(d, keys_tuple): for key in keys_tuple: if d is None: return None if key not in keys_tuple: return None d = d[key] return d class TaskWriter: def __init__(self, project_id, category_none_id) -> None: self.project_id = project_id self.category_none_id = category_none_id async def write_task_to_db(self, task_notion_id): task_notion = await notion.pages.retrieve(task_notion_id) task_notion = task_notion[\"properties\"] task_notion = TaskParser(task_notion) if task_notion.get_title() is None: return async with get_session_context() as session: category_id = await self._get_category_id(session, task_notion) task_data = { \"category_id\": category_id, # \u0411\u0443\u0434\u0435\u043c \u0437\u0430\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u043d\u0438\u0436\u0435 \"title\": task_notion.get_title(), \"description\": None, \"deadline\": task_notion.get_deadline(), \"priority\": task_notion.get_priority(), \"approximate_time\": task_notion.get_approximate_time(), } task_object = models.Task.model_validate(task_data) session.add(task_object) await session.commit() await session.refresh(task_object) async def _get_category_id(self, session, task_notion: TaskParser): category_title = task_notion.get_category_title() if category_title is None: return self.category_none_id # try to find category with that name category_obj = await self._find_category_obj( session, category_title, ) if category_obj is None: category_obj = await self._create_category_obj(session, category_title) # Attribute error try: category_id = category_obj.id except AttributeError as e: print(category_obj) raise e return category_id async def _find_category_obj(self, session, category_title): query = ( select(models.Category) .where(models.Category.title == category_title) .where(models.Category.project_id == self.project_id) ) results = await session.exec(query) category_obj = results.first() if category_obj is not None: category_obj = category_obj[0] return category_obj async def _create_category_obj(self, session, category_title): category_data = { \"project_id\": self.project_id, \"title\": category_title, \"description\": None, } category_obj = models.Category.model_validate(category_data) session.add(category_obj) await session.commit() await session.refresh(category_obj) return category_obj async def create_project(): url = \"http://127.0.0.1:13213/project/\" json_data = { \"title\": \"Notion tasks project async\", \"description\": \"Async notion tasks\", } response = requests.post(url, headers=headers, json=json_data).json() project_id = response[\"object\"][\"id\"] return project_id async def create_none_category(project_id): url = f\"http://127.0.0.1:13213/project/{project_id}/category/\" json_data = { \"title\": \"None category\", \"description\": \"If no category, it falls here\", } response = requests.post(url, headers=headers, json=json_data).json() category_id = response[\"object\"][\"id\"] return category_id async def main(): logger.info(\"\u041d\u0430\u0447\u0430\u043b \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435\") project_id = await create_project() category_none_id = await create_none_category(project_id) logger.info(\"\u0421\u043e\u0437\u0434\u0430\u043b \u043f\u0440\u043e\u0435\u043a\u0442 \u0438 none task\") task_pages = await get_task_pages(db_id) logger.info(\"\u041f\u043e\u043b\u0443\u0447\u0438\u043b id \u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0442\u0430\u0441\u043a\u043e\u0432\") task_writer = TaskWriter(project_id, category_none_id) async with asyncio.TaskGroup() as task_group: for task_id in task_pages: coroutine = task_writer.write_task_to_db(task_id) task_group.create_task(coroutine) logger.info(\"\u0421\u043e\u0431\u0440\u0430\u043b \u0432\u0441\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u043b \u0438\u0445 \u0432 \u0411\u0414\") if __name__ == \"__main__\": logger.reset_time() asyncio.run(main())","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0447\u0435\u0440\u0435\u0437 AsyncIO"},{"location":"lab2/task2_asyncio/#asyncio","text":"\u041a\u043e\u0434: from dotenv import dotenv_values from pathlib import Path from notion_client import AsyncClient from dataclasses import dataclass from datetime import datetime import models from sqlalchemy import select from db_connection import get_session_context import asyncio import requests from elapsed_logging import logger from uuid import UUID exercise2_path = Path(__file__).parent.parent env_path = exercise2_path / \".env\" config = dotenv_values(env_path) notion_secret = config[\"notion_secret\"] db_id = \"7401d3f130414235ab1abb429d41a31e\" headers = { \"Authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NjM0NTQ4NzUsImlhdCI6MTcxNTQ1NDg3NSwic3ViIjoidXNlcjEifQ.u4I3i-utbj3gwwlLc9ABIfvKneg-Ri3VzZVkmoNh-Wc\" } notion = AsyncClient(auth=notion_secret) async def get_task_pages(db_id: str): \"\"\"\u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u0432\u0441\u0435 id \u0441\u0442\u0440\u0430\u043d\u0438\u0446, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043d\u0430\u0445\u043e\u0434\u044f\u0442\u0441\u044f \u0432 \u0411\u0414 Args: db_id (str): id \u0411\u0414 \u0432 notion Returns: list[str]: \u0421\u043f\u0438\u0441\u043e\u043a id \u0441\u0442\u0440\u0430\u043d\u0438\u0446 \"\"\" response = await notion.databases.query(db_id) entries_list = response[\"results\"] page_ids = [] for entry in entries_list: if entry[\"object\"] == \"page\": page_id = entry[\"id\"] page_ids.append(page_id) return page_ids class TaskParser: def __init__(self, task_notion: dict) -> None: self.task_notion = task_notion def get_title(self) -> str | None: title_list = self.get_value_or_none( self.task_notion, [\"Name\", \"title\"] ) if len(title_list) == 0: return None title_object = title_list[0] title = self.get_value_or_none( title_object, ['plain_text'] ) return title def get_category_title(self) -> str | None: title = self.get_value_or_none( self.task_notion, (\"Tasks\", \"select\", \"name\") ) return title def get_description(self) -> str | None: return None def get_deadline(self) -> str | None: deadline = self.get_value_or_none( self.task_notion, (\"due\", \"date\", \"start\") ) return deadline def get_priority(self) -> models.Priority | None: urgent_flag = self.get_value_or_none( self.task_notion, ['Urgent', 'checkbox'] ) if urgent_flag: return models.Priority.high return models.Priority.low def get_approximate_time(self) -> int | None: approximate_time = self.get_value_or_none( self.task_notion, [\"Aproximate time\", 'number'] ) if approximate_time is not None: approximate_time = int(approximate_time) return approximate_time @staticmethod def get_value_or_none(d, keys_tuple): for key in keys_tuple: if d is None: return None if key not in keys_tuple: return None d = d[key] return d class TaskWriter: def __init__(self, project_id, category_none_id) -> None: self.project_id = project_id self.category_none_id = category_none_id async def write_task_to_db(self, task_notion_id): task_notion = await notion.pages.retrieve(task_notion_id) task_notion = task_notion[\"properties\"] task_notion = TaskParser(task_notion) if task_notion.get_title() is None: return async with get_session_context() as session: category_id = await self._get_category_id(session, task_notion) task_data = { \"category_id\": category_id, # \u0411\u0443\u0434\u0435\u043c \u0437\u0430\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u043d\u0438\u0436\u0435 \"title\": task_notion.get_title(), \"description\": None, \"deadline\": task_notion.get_deadline(), \"priority\": task_notion.get_priority(), \"approximate_time\": task_notion.get_approximate_time(), } task_object = models.Task.model_validate(task_data) session.add(task_object) await session.commit() await session.refresh(task_object) async def _get_category_id(self, session, task_notion: TaskParser): category_title = task_notion.get_category_title() if category_title is None: return self.category_none_id # try to find category with that name category_obj = await self._find_category_obj( session, category_title, ) if category_obj is None: category_obj = await self._create_category_obj(session, category_title) # Attribute error try: category_id = category_obj.id except AttributeError as e: print(category_obj) raise e return category_id async def _find_category_obj(self, session, category_title): query = ( select(models.Category) .where(models.Category.title == category_title) .where(models.Category.project_id == self.project_id) ) results = await session.exec(query) category_obj = results.first() if category_obj is not None: category_obj = category_obj[0] return category_obj async def _create_category_obj(self, session, category_title): category_data = { \"project_id\": self.project_id, \"title\": category_title, \"description\": None, } category_obj = models.Category.model_validate(category_data) session.add(category_obj) await session.commit() await session.refresh(category_obj) return category_obj async def create_project(): url = \"http://127.0.0.1:13213/project/\" json_data = { \"title\": \"Notion tasks project async\", \"description\": \"Async notion tasks\", } response = requests.post(url, headers=headers, json=json_data).json() project_id = response[\"object\"][\"id\"] return project_id async def create_none_category(project_id): url = f\"http://127.0.0.1:13213/project/{project_id}/category/\" json_data = { \"title\": \"None category\", \"description\": \"If no category, it falls here\", } response = requests.post(url, headers=headers, json=json_data).json() category_id = response[\"object\"][\"id\"] return category_id async def main(): logger.info(\"\u041d\u0430\u0447\u0430\u043b \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435\") project_id = await create_project() category_none_id = await create_none_category(project_id) logger.info(\"\u0421\u043e\u0437\u0434\u0430\u043b \u043f\u0440\u043e\u0435\u043a\u0442 \u0438 none task\") task_pages = await get_task_pages(db_id) logger.info(\"\u041f\u043e\u043b\u0443\u0447\u0438\u043b id \u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0442\u0430\u0441\u043a\u043e\u0432\") task_writer = TaskWriter(project_id, category_none_id) async with asyncio.TaskGroup() as task_group: for task_id in task_pages: coroutine = task_writer.write_task_to_db(task_id) task_group.create_task(coroutine) logger.info(\"\u0421\u043e\u0431\u0440\u0430\u043b \u0432\u0441\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u043b \u0438\u0445 \u0432 \u0411\u0414\") if __name__ == \"__main__\": logger.reset_time() asyncio.run(main())","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0447\u0435\u0440\u0435\u0437 AsyncIO"},{"location":"lab2/task2_auxilary/","text":"\u0412\u0441\u043f\u043e\u043c\u043e\u0433\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043c\u043e\u0434\u0443\u043b\u0438 \u041c\u043e\u0434\u0443\u043b\u044c \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0449\u0435\u043d\u0438\u044f \u043a \u0411\u0414(\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u044b\u0439) from dotenv import dotenv_values from contextlib import contextmanager from pathlib import Path from sqlmodel import Session, create_engine from typing import Iterator env_path = Path(__file__).parent.parent / '.env' config = dotenv_values(env_path) db_url = config['DB_ADMIN_SYNC'] engine = create_engine(db_url) @contextmanager def get_session_context() -> Iterator[Session]: session = Session(engine) try: yield session finally: session.close() # Depends \u0437\u0430\u043c \u043f\u043e\u0437\u0430\u0431\u043e\u0442\u0438\u0442\u0441\u044f \u043e \u0437\u0430\u043a\u0440\u044b\u0442\u0438\u0438 \u0441\u0435\u0441\u0441\u0438\u0438, \u043a\u043e\u0433\u0434\u0430 \u043f\u0438\u0448\u0435\u043c \u0433\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440 def get_session_depends() -> Iterator[Session]: with Session(engine) as session: yield session \u041c\u043e\u0434\u0443\u043b\u044c \u0434\u043b\u044f \u0441\u0432\u044f\u0437\u0438 \u0441 \u0411\u0414(\u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u044b\u0439) from pathlib import Path from dotenv import dotenv_values from sqlalchemy.ext.asyncio import create_async_engine from sqlalchemy.ext.asyncio import async_sessionmaker from sqlmodel import SQLModel from sqlmodel.ext.asyncio.session import AsyncSession from contextlib import asynccontextmanager from typing import AsyncIterator env_path = Path(__file__).parent.parent / '.env' config = dotenv_values(env_path) db_url = config['DB_ADMIN_ASYNC'] async_engine = create_async_engine( db_url, future=True ) async def init_db(): async with async_engine.begin() as conn: await conn.run_sync(SQLModel.metadata.create_all) @asynccontextmanager async def get_session_context() -> AsyncIterator[AsyncSession]: # \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432 \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e\u043c \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043d\u043e\u043c \u043c\u0435\u043d\u0435\u0434\u0436\u0435\u0440\u0435 session_maker = async_sessionmaker( bind=async_engine, class_=AsyncSession, expire_on_commit=False ) session = session_maker() try: yield session finally: await session.close() async def get_session_depends() -> AsyncIterator[AsyncSession]: # \u0421\u0435\u0441\u0441\u0438\u044f \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432 depends \u0432 fastAPI async_session = async_sessionmaker( bind=async_engine, class_=AsyncSession, expire_on_commit=False ) async with async_session() as session: yield session async def engine_dispose(): # \u0420\u0430\u0437\u043e\u0440\u0432\u0430\u0442\u044c \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u0411\u0414 await async_engine.dispose() \u041a\u043b\u0430\u0441\u0441 \u0434\u043b\u044f \u043b\u043e\u0433\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f import logging import time # Custom formatter class class _TimedLogger: \"\"\"Logger class that prefixes each message with elapsed time since instantiation.\"\"\" def __init__(self): self.reset_time() def reset_time(self): self.start_time = time.time() self.logger = logging.getLogger(\"logger\") self.logger.setLevel(logging.INFO) # Set the desired default logging level # Create a StreamHandler with a custom formatter stream_handler = logging.StreamHandler() stream_handler.setFormatter(self._CustomFormatter(self.start_time)) # Clear existing handlers to avoid duplicate logs in case of reinitialization self.logger.handlers = [] self.logger.addHandler(stream_handler) class _CustomFormatter(logging.Formatter): \"\"\"Custom formatter to add time since start to logs.\"\"\" def __init__(self, start_time): super().__init__(\"%(message)s\") self.start_time = start_time def format(self, record): elapsed_seconds = time.time() - self.start_time # Format time as seconds.milliseconds formatted_time = f\"{int(elapsed_seconds)}.{int((elapsed_seconds - int(elapsed_seconds)) * 1000)}\" # Set the prefix with formatted time record.msg = f\"[{formatted_time}] {record.msg}\" return super().format(record) def info(self, msg): self.logger.info(msg) def debug(self, msg): self.logger.debug(msg) logger = _TimedLogger() \u041a\u043b\u0430\u0441\u0441 \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u044f\u043c\u0438 import threading from sqlalchemy import select import models class CategoryManager: def __init__(self, project_id, category_none_id): self._category_none_id = category_none_id self._project_id = project_id self._category_locks = {} self._category_ids = {} def _get_lock(self, category): \"\"\"Retrieve a unique lock for each category.\"\"\" if category not in self._category_locks: self._category_locks[category] = threading.Lock() return self._category_locks[category] def _find_category_obj_db(self, session, category_title): query = ( select(models.Category) .where(models.Category.title == category_title) .where(models.Category.project_id == self._project_id) ) results = session.exec(query) category_obj = results.first() if category_obj is None: return None return category_obj[0].id def _create_category_obj(self, session, category_title): category_data = { \"project_id\": self._project_id, \"title\": category_title, \"description\": None, } category_obj = models.Category.model_validate(category_data) session.add(category_obj) session.commit() session.refresh(category_obj) return category_obj.id def _get_id(self, session, category_title): category_id = self._category_ids.get(category_title) if category_id is not None: return category_id category_id = self._find_category_obj_db(session, category_title) if category_id is not None: return category_id category_id = self._create_category_obj(session, category_title) return category_id def get_id(self, session, category_title): if category_title is None: return self._category_none_id with self._get_lock(category_title): category_id = self._get_id(session, category_title) self._category_ids[category_title] = category_id return category_id","title":"\u0412\u0441\u043f\u043e\u043c\u043e\u0433\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043c\u043e\u0434\u0443\u043b\u0438"},{"location":"lab2/task2_auxilary/#_1","text":"","title":"\u0412\u0441\u043f\u043e\u043c\u043e\u0433\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043c\u043e\u0434\u0443\u043b\u0438"},{"location":"lab2/task2_auxilary/#_2","text":"from dotenv import dotenv_values from contextlib import contextmanager from pathlib import Path from sqlmodel import Session, create_engine from typing import Iterator env_path = Path(__file__).parent.parent / '.env' config = dotenv_values(env_path) db_url = config['DB_ADMIN_SYNC'] engine = create_engine(db_url) @contextmanager def get_session_context() -> Iterator[Session]: session = Session(engine) try: yield session finally: session.close() # Depends \u0437\u0430\u043c \u043f\u043e\u0437\u0430\u0431\u043e\u0442\u0438\u0442\u0441\u044f \u043e \u0437\u0430\u043a\u0440\u044b\u0442\u0438\u0438 \u0441\u0435\u0441\u0441\u0438\u0438, \u043a\u043e\u0433\u0434\u0430 \u043f\u0438\u0448\u0435\u043c \u0433\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440 def get_session_depends() -> Iterator[Session]: with Session(engine) as session: yield session","title":"\u041c\u043e\u0434\u0443\u043b\u044c \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0449\u0435\u043d\u0438\u044f \u043a \u0411\u0414(\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u044b\u0439)"},{"location":"lab2/task2_auxilary/#_3","text":"from pathlib import Path from dotenv import dotenv_values from sqlalchemy.ext.asyncio import create_async_engine from sqlalchemy.ext.asyncio import async_sessionmaker from sqlmodel import SQLModel from sqlmodel.ext.asyncio.session import AsyncSession from contextlib import asynccontextmanager from typing import AsyncIterator env_path = Path(__file__).parent.parent / '.env' config = dotenv_values(env_path) db_url = config['DB_ADMIN_ASYNC'] async_engine = create_async_engine( db_url, future=True ) async def init_db(): async with async_engine.begin() as conn: await conn.run_sync(SQLModel.metadata.create_all) @asynccontextmanager async def get_session_context() -> AsyncIterator[AsyncSession]: # \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432 \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e\u043c \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u043d\u043e\u043c \u043c\u0435\u043d\u0435\u0434\u0436\u0435\u0440\u0435 session_maker = async_sessionmaker( bind=async_engine, class_=AsyncSession, expire_on_commit=False ) session = session_maker() try: yield session finally: await session.close() async def get_session_depends() -> AsyncIterator[AsyncSession]: # \u0421\u0435\u0441\u0441\u0438\u044f \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432 depends \u0432 fastAPI async_session = async_sessionmaker( bind=async_engine, class_=AsyncSession, expire_on_commit=False ) async with async_session() as session: yield session async def engine_dispose(): # \u0420\u0430\u0437\u043e\u0440\u0432\u0430\u0442\u044c \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 \u0441 \u0411\u0414 await async_engine.dispose()","title":"\u041c\u043e\u0434\u0443\u043b\u044c \u0434\u043b\u044f \u0441\u0432\u044f\u0437\u0438 \u0441 \u0411\u0414(\u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u044b\u0439)"},{"location":"lab2/task2_auxilary/#_4","text":"import logging import time # Custom formatter class class _TimedLogger: \"\"\"Logger class that prefixes each message with elapsed time since instantiation.\"\"\" def __init__(self): self.reset_time() def reset_time(self): self.start_time = time.time() self.logger = logging.getLogger(\"logger\") self.logger.setLevel(logging.INFO) # Set the desired default logging level # Create a StreamHandler with a custom formatter stream_handler = logging.StreamHandler() stream_handler.setFormatter(self._CustomFormatter(self.start_time)) # Clear existing handlers to avoid duplicate logs in case of reinitialization self.logger.handlers = [] self.logger.addHandler(stream_handler) class _CustomFormatter(logging.Formatter): \"\"\"Custom formatter to add time since start to logs.\"\"\" def __init__(self, start_time): super().__init__(\"%(message)s\") self.start_time = start_time def format(self, record): elapsed_seconds = time.time() - self.start_time # Format time as seconds.milliseconds formatted_time = f\"{int(elapsed_seconds)}.{int((elapsed_seconds - int(elapsed_seconds)) * 1000)}\" # Set the prefix with formatted time record.msg = f\"[{formatted_time}] {record.msg}\" return super().format(record) def info(self, msg): self.logger.info(msg) def debug(self, msg): self.logger.debug(msg) logger = _TimedLogger()","title":"\u041a\u043b\u0430\u0441\u0441 \u0434\u043b\u044f \u043b\u043e\u0433\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f"},{"location":"lab2/task2_auxilary/#_5","text":"import threading from sqlalchemy import select import models class CategoryManager: def __init__(self, project_id, category_none_id): self._category_none_id = category_none_id self._project_id = project_id self._category_locks = {} self._category_ids = {} def _get_lock(self, category): \"\"\"Retrieve a unique lock for each category.\"\"\" if category not in self._category_locks: self._category_locks[category] = threading.Lock() return self._category_locks[category] def _find_category_obj_db(self, session, category_title): query = ( select(models.Category) .where(models.Category.title == category_title) .where(models.Category.project_id == self._project_id) ) results = session.exec(query) category_obj = results.first() if category_obj is None: return None return category_obj[0].id def _create_category_obj(self, session, category_title): category_data = { \"project_id\": self._project_id, \"title\": category_title, \"description\": None, } category_obj = models.Category.model_validate(category_data) session.add(category_obj) session.commit() session.refresh(category_obj) return category_obj.id def _get_id(self, session, category_title): category_id = self._category_ids.get(category_title) if category_id is not None: return category_id category_id = self._find_category_obj_db(session, category_title) if category_id is not None: return category_id category_id = self._create_category_obj(session, category_title) return category_id def get_id(self, session, category_title): if category_title is None: return self._category_none_id with self._get_lock(category_title): category_id = self._get_id(session, category_title) self._category_ids[category_title] = category_id return category_id","title":"\u041a\u043b\u0430\u0441\u0441 \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 \u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u044f\u043c\u0438"},{"location":"lab2/task2_conclusion/","text":"\u0412\u044b\u0432\u043e\u0434\u044b \u041f\u043e\u0434\u0445\u043e\u0434/\u043f\u043e\u043f\u044b\u0442\u043a\u0430 1 2 3 AsyncIO 5.1 3.6 4.2 Threading 2.409 3.4 3.0 Multiprocessing(4 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430) 8.6 9 7 \u0412\u0438\u0434\u0438\u043c, \u0447\u0442\u043e \u043d\u0430\u0438\u043b\u0443\u0447\u0448\u0443\u044e \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0442 AsyncIO \u0438 threading. \u042d\u0442\u043e \u043c\u043e\u0436\u043d\u043e \u043e\u0431\u044a\u044f\u0441\u043d\u0438\u0442\u044c \u0442\u0435\u043c, \u0447\u0442\u043e \u0432 \u043d\u0430\u0448\u0435\u0439 \u0437\u0430\u0434\u0430\u0447\u0435 \u043d\u0435 \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0431\u043e\u043b\u044c\u0448\u0430\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c. \u042d\u0442\u0430 \u0437\u0430\u0434\u0430\u0447\u0430 \u0442\u0440\u0435\u0431\u0443\u0435\u0442 \u0442\u043e\u043b\u044c\u043a\u043e \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u0432\u0432\u043e\u0434\u0430.","title":"\u0412\u044b\u0432\u043e\u0434\u044b"},{"location":"lab2/task2_conclusion/#_1","text":"\u041f\u043e\u0434\u0445\u043e\u0434/\u043f\u043e\u043f\u044b\u0442\u043a\u0430 1 2 3 AsyncIO 5.1 3.6 4.2 Threading 2.409 3.4 3.0 Multiprocessing(4 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0430) 8.6 9 7 \u0412\u0438\u0434\u0438\u043c, \u0447\u0442\u043e \u043d\u0430\u0438\u043b\u0443\u0447\u0448\u0443\u044e \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u044e\u0442 AsyncIO \u0438 threading. \u042d\u0442\u043e \u043c\u043e\u0436\u043d\u043e \u043e\u0431\u044a\u044f\u0441\u043d\u0438\u0442\u044c \u0442\u0435\u043c, \u0447\u0442\u043e \u0432 \u043d\u0430\u0448\u0435\u0439 \u0437\u0430\u0434\u0430\u0447\u0435 \u043d\u0435 \u0442\u0440\u0435\u0431\u0443\u0435\u0442\u0441\u044f \u0431\u043e\u043b\u044c\u0448\u0430\u044f \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u0430\u044f \u043c\u043e\u0449\u043d\u043e\u0441\u0442\u044c. \u042d\u0442\u0430 \u0437\u0430\u0434\u0430\u0447\u0430 \u0442\u0440\u0435\u0431\u0443\u0435\u0442 \u0442\u043e\u043b\u044c\u043a\u043e \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f \u0432\u0432\u043e\u0434\u0430.","title":"\u0412\u044b\u0432\u043e\u0434\u044b"},{"location":"lab2/task2_multiprocessing/","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0447\u0435\u0440\u0435\u0437 multiprocessing from pathlib import Path import multiprocessing import models import requests from db_connection import get_session_context from dotenv import dotenv_values from elapsed_logging import logger from notion_client import Client from category_manager import CategoryManager from task_parser import TaskParser import math exercise2_path = Path(__file__).parent.parent env_path = exercise2_path / \".env\" config = dotenv_values(env_path) notion_secret = config[\"notion_secret\"] db_id = \"7401d3f130414235ab1abb429d41a31e\" headers = { \"Authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NjM0NTQ4NzUsImlhdCI6MTcxNTQ1NDg3NSwic3ViIjoidXNlcjEifQ.u4I3i-utbj3gwwlLc9ABIfvKneg-Ri3VzZVkmoNh-Wc\" } notion = Client(auth=notion_secret) def get_task_pages(db_id: str): \"\"\"\u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u0432\u0441\u0435 id \u0441\u0442\u0440\u0430\u043d\u0438\u0446, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043d\u0430\u0445\u043e\u0434\u044f\u0442\u0441\u044f \u0432 \u0411\u0414 Args: db_id (str): id \u0411\u0414 \u0432 notion Returns: list[str]: \u0421\u043f\u0438\u0441\u043e\u043a id \u0441\u0442\u0440\u0430\u043d\u0438\u0446 \"\"\" response = notion.databases.query(db_id) entries_list = response[\"results\"] page_ids = [] for entry in entries_list: if entry[\"object\"] == \"page\": page_id = entry[\"id\"] page_ids.append(page_id) return page_ids class TaskWriter: def __init__(self, category_manager: CategoryManager) -> None: self.category_manager = category_manager def write_task_to_db(self, task_notion_id): task_notion = notion.pages.retrieve(task_notion_id) task_notion = task_notion[\"properties\"] task_notion = TaskParser(task_notion) if task_notion.get_title() is None: return with get_session_context() as session: category_title = task_notion.get_category_title() category_id = self.category_manager.get_id(session, category_title) task_data = { \"category_id\": category_id, # \u0411\u0443\u0434\u0435\u043c \u0437\u0430\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u043d\u0438\u0436\u0435 \"title\": task_notion.get_title(), \"description\": None, \"deadline\": task_notion.get_deadline(), \"priority\": task_notion.get_priority(), \"approximate_time\": task_notion.get_approximate_time(), } task_object = models.Task.model_validate(task_data) session.add(task_object) session.commit() session.refresh(task_object) def create_project(): url = \"http://127.0.0.1:13213/project/\" json_data = { \"title\": \"Notion tasks project threading\", \"description\": \"Threading notion tasks\", } response = requests.post(url, headers=headers, json=json_data).json() project_id = response[\"object\"][\"id\"] return project_id def create_none_category(project_id): url = f\"http://127.0.0.1:13213/project/{project_id}/category/\" json_data = { \"title\": \"None category\", \"description\": \"If no category, it falls here\", } response = requests.post(url, headers=headers, json=json_data).json() category_id = response[\"object\"][\"id\"] return category_id def handle_tasks_in_process(task_ids, task_writer): for task_id in task_ids: task_writer.write_task_to_db(task_id) def handle_tasks_with_threading(task_ids, task_writer, n_threads): start = 0 end = len(task_ids) step = int(math.ceil((end - start) / n_threads)) start_i = start processes = [] while start_i <= end: end_i = min(start_i + step, end) process = multiprocessing.Process( target=handle_tasks_in_process, args=[task_ids[start_i : end_i + 1], task_writer], ) process.start() processes.append(process) start_i = end_i + 1 for process in processes: process.join() def main(): logger.reset_time() logger.info(\"\u041d\u0430\u0447\u0430\u043b \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435\") project_id = create_project() category_none_id = create_none_category(project_id) logger.info(\"\u0421\u043e\u0437\u0434\u0430\u043b \u043f\u0440\u043e\u0435\u043a\u0442 \u0438 none task\") task_ids = get_task_pages(db_id) logger.info(\"\u041f\u043e\u043b\u0443\u0447\u0438\u043b id \u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0442\u0430\u0441\u043a\u043e\u0432\") category_manager = CategoryManager(project_id, category_none_id) task_writer = TaskWriter(category_manager) handle_tasks_with_threading(task_ids, task_writer, 4) logger.info(\"\u0421\u043e\u0431\u0440\u0430\u043b \u0432\u0441\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u043b \u0438\u0445 \u0432 \u0411\u0414\") if __name__ == \"__main__\": main()","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0447\u0435\u0440\u0435\u0437 multiprocessing"},{"location":"lab2/task2_multiprocessing/#multiprocessing","text":"from pathlib import Path import multiprocessing import models import requests from db_connection import get_session_context from dotenv import dotenv_values from elapsed_logging import logger from notion_client import Client from category_manager import CategoryManager from task_parser import TaskParser import math exercise2_path = Path(__file__).parent.parent env_path = exercise2_path / \".env\" config = dotenv_values(env_path) notion_secret = config[\"notion_secret\"] db_id = \"7401d3f130414235ab1abb429d41a31e\" headers = { \"Authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NjM0NTQ4NzUsImlhdCI6MTcxNTQ1NDg3NSwic3ViIjoidXNlcjEifQ.u4I3i-utbj3gwwlLc9ABIfvKneg-Ri3VzZVkmoNh-Wc\" } notion = Client(auth=notion_secret) def get_task_pages(db_id: str): \"\"\"\u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u0432\u0441\u0435 id \u0441\u0442\u0440\u0430\u043d\u0438\u0446, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043d\u0430\u0445\u043e\u0434\u044f\u0442\u0441\u044f \u0432 \u0411\u0414 Args: db_id (str): id \u0411\u0414 \u0432 notion Returns: list[str]: \u0421\u043f\u0438\u0441\u043e\u043a id \u0441\u0442\u0440\u0430\u043d\u0438\u0446 \"\"\" response = notion.databases.query(db_id) entries_list = response[\"results\"] page_ids = [] for entry in entries_list: if entry[\"object\"] == \"page\": page_id = entry[\"id\"] page_ids.append(page_id) return page_ids class TaskWriter: def __init__(self, category_manager: CategoryManager) -> None: self.category_manager = category_manager def write_task_to_db(self, task_notion_id): task_notion = notion.pages.retrieve(task_notion_id) task_notion = task_notion[\"properties\"] task_notion = TaskParser(task_notion) if task_notion.get_title() is None: return with get_session_context() as session: category_title = task_notion.get_category_title() category_id = self.category_manager.get_id(session, category_title) task_data = { \"category_id\": category_id, # \u0411\u0443\u0434\u0435\u043c \u0437\u0430\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u043d\u0438\u0436\u0435 \"title\": task_notion.get_title(), \"description\": None, \"deadline\": task_notion.get_deadline(), \"priority\": task_notion.get_priority(), \"approximate_time\": task_notion.get_approximate_time(), } task_object = models.Task.model_validate(task_data) session.add(task_object) session.commit() session.refresh(task_object) def create_project(): url = \"http://127.0.0.1:13213/project/\" json_data = { \"title\": \"Notion tasks project threading\", \"description\": \"Threading notion tasks\", } response = requests.post(url, headers=headers, json=json_data).json() project_id = response[\"object\"][\"id\"] return project_id def create_none_category(project_id): url = f\"http://127.0.0.1:13213/project/{project_id}/category/\" json_data = { \"title\": \"None category\", \"description\": \"If no category, it falls here\", } response = requests.post(url, headers=headers, json=json_data).json() category_id = response[\"object\"][\"id\"] return category_id def handle_tasks_in_process(task_ids, task_writer): for task_id in task_ids: task_writer.write_task_to_db(task_id) def handle_tasks_with_threading(task_ids, task_writer, n_threads): start = 0 end = len(task_ids) step = int(math.ceil((end - start) / n_threads)) start_i = start processes = [] while start_i <= end: end_i = min(start_i + step, end) process = multiprocessing.Process( target=handle_tasks_in_process, args=[task_ids[start_i : end_i + 1], task_writer], ) process.start() processes.append(process) start_i = end_i + 1 for process in processes: process.join() def main(): logger.reset_time() logger.info(\"\u041d\u0430\u0447\u0430\u043b \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435\") project_id = create_project() category_none_id = create_none_category(project_id) logger.info(\"\u0421\u043e\u0437\u0434\u0430\u043b \u043f\u0440\u043e\u0435\u043a\u0442 \u0438 none task\") task_ids = get_task_pages(db_id) logger.info(\"\u041f\u043e\u043b\u0443\u0447\u0438\u043b id \u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0442\u0430\u0441\u043a\u043e\u0432\") category_manager = CategoryManager(project_id, category_none_id) task_writer = TaskWriter(category_manager) handle_tasks_with_threading(task_ids, task_writer, 4) logger.info(\"\u0421\u043e\u0431\u0440\u0430\u043b \u0432\u0441\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u043b \u0438\u0445 \u0432 \u0411\u0414\") if __name__ == \"__main__\": main()","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0447\u0435\u0440\u0435\u0437 multiprocessing"},{"location":"lab2/task2_threading/","text":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0447\u0435\u0440\u0435\u0437 threading from pathlib import Path from concurrent.futures import ThreadPoolExecutor import models import requests from db_connection import get_session_context from dotenv import dotenv_values from elapsed_logging import logger from notion_client import Client from category_manager import CategoryManager from task_parser import TaskParser exercise2_path = Path(__file__).parent.parent env_path = exercise2_path / \".env\" config = dotenv_values(env_path) notion_secret = config[\"notion_secret\"] db_id = \"7401d3f130414235ab1abb429d41a31e\" headers = { \"Authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NjM0NTQ4NzUsImlhdCI6MTcxNTQ1NDg3NSwic3ViIjoidXNlcjEifQ.u4I3i-utbj3gwwlLc9ABIfvKneg-Ri3VzZVkmoNh-Wc\" } notion = Client(auth=notion_secret) def get_task_pages(db_id: str): \"\"\"\u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u0432\u0441\u0435 id \u0441\u0442\u0440\u0430\u043d\u0438\u0446, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043d\u0430\u0445\u043e\u0434\u044f\u0442\u0441\u044f \u0432 \u0411\u0414 Args: db_id (str): id \u0411\u0414 \u0432 notion Returns: list[str]: \u0421\u043f\u0438\u0441\u043e\u043a id \u0441\u0442\u0440\u0430\u043d\u0438\u0446 \"\"\" response = notion.databases.query(db_id) entries_list = response[\"results\"] page_ids = [] for entry in entries_list: if entry[\"object\"] == \"page\": page_id = entry[\"id\"] page_ids.append(page_id) return page_ids class TaskWriter: def __init__(self, category_manager: CategoryManager) -> None: self.category_manager = category_manager def write_task_to_db(self, task_notion_id): task_notion = notion.pages.retrieve(task_notion_id) task_notion = task_notion[\"properties\"] task_notion = TaskParser(task_notion) if task_notion.get_title() is None: return with get_session_context() as session: category_title = task_notion.get_category_title() category_id = self.category_manager.get_id(session, category_title) task_data = { \"category_id\": category_id, # \u0411\u0443\u0434\u0435\u043c \u0437\u0430\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u043d\u0438\u0436\u0435 \"title\": task_notion.get_title(), \"description\": None, \"deadline\": task_notion.get_deadline(), \"priority\": task_notion.get_priority(), \"approximate_time\": task_notion.get_approximate_time(), } task_object = models.Task.model_validate(task_data) session.add(task_object) session.commit() session.refresh(task_object) def create_project(): url = \"http://127.0.0.1:13213/project/\" json_data = { \"title\": \"Notion tasks project threading\", \"description\": \"Threading notion tasks\", } response = requests.post(url, headers=headers, json=json_data).json() project_id = response[\"object\"][\"id\"] return project_id def create_none_category(project_id): url = f\"http://127.0.0.1:13213/project/{project_id}/category/\" json_data = { \"title\": \"None category\", \"description\": \"If no category, it falls here\", } response = requests.post(url, headers=headers, json=json_data).json() category_id = response[\"object\"][\"id\"] return category_id def main(): logger.reset_time() logger.info(\"\u041d\u0430\u0447\u0430\u043b \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435\") project_id = create_project() category_none_id = create_none_category(project_id) logger.info(\"\u0421\u043e\u0437\u0434\u0430\u043b \u043f\u0440\u043e\u0435\u043a\u0442 \u0438 none task\") task_pages = get_task_pages(db_id) logger.info(\"\u041f\u043e\u043b\u0443\u0447\u0438\u043b id \u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0442\u0430\u0441\u043a\u043e\u0432\") category_manager = CategoryManager(project_id, category_none_id) task_writer = TaskWriter(category_manager) with ThreadPoolExecutor() as executor: results = executor.map(task_writer.write_task_to_db, task_pages) try: for result in results: pass except Exception as e: print(e) logger.info(\"\u0421\u043e\u0431\u0440\u0430\u043b \u0432\u0441\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u043b \u0438\u0445 \u0432 \u0411\u0414\") if __name__ == \"__main__\": main()","title":"Task2 threading"},{"location":"lab2/task2_threading/#threading","text":"from pathlib import Path from concurrent.futures import ThreadPoolExecutor import models import requests from db_connection import get_session_context from dotenv import dotenv_values from elapsed_logging import logger from notion_client import Client from category_manager import CategoryManager from task_parser import TaskParser exercise2_path = Path(__file__).parent.parent env_path = exercise2_path / \".env\" config = dotenv_values(env_path) notion_secret = config[\"notion_secret\"] db_id = \"7401d3f130414235ab1abb429d41a31e\" headers = { \"Authorization\": \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NjM0NTQ4NzUsImlhdCI6MTcxNTQ1NDg3NSwic3ViIjoidXNlcjEifQ.u4I3i-utbj3gwwlLc9ABIfvKneg-Ri3VzZVkmoNh-Wc\" } notion = Client(auth=notion_secret) def get_task_pages(db_id: str): \"\"\"\u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u0432\u0441\u0435 id \u0441\u0442\u0440\u0430\u043d\u0438\u0446, \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043d\u0430\u0445\u043e\u0434\u044f\u0442\u0441\u044f \u0432 \u0411\u0414 Args: db_id (str): id \u0411\u0414 \u0432 notion Returns: list[str]: \u0421\u043f\u0438\u0441\u043e\u043a id \u0441\u0442\u0440\u0430\u043d\u0438\u0446 \"\"\" response = notion.databases.query(db_id) entries_list = response[\"results\"] page_ids = [] for entry in entries_list: if entry[\"object\"] == \"page\": page_id = entry[\"id\"] page_ids.append(page_id) return page_ids class TaskWriter: def __init__(self, category_manager: CategoryManager) -> None: self.category_manager = category_manager def write_task_to_db(self, task_notion_id): task_notion = notion.pages.retrieve(task_notion_id) task_notion = task_notion[\"properties\"] task_notion = TaskParser(task_notion) if task_notion.get_title() is None: return with get_session_context() as session: category_title = task_notion.get_category_title() category_id = self.category_manager.get_id(session, category_title) task_data = { \"category_id\": category_id, # \u0411\u0443\u0434\u0435\u043c \u0437\u0430\u043f\u043e\u043b\u043d\u044f\u0442\u044c \u043d\u0438\u0436\u0435 \"title\": task_notion.get_title(), \"description\": None, \"deadline\": task_notion.get_deadline(), \"priority\": task_notion.get_priority(), \"approximate_time\": task_notion.get_approximate_time(), } task_object = models.Task.model_validate(task_data) session.add(task_object) session.commit() session.refresh(task_object) def create_project(): url = \"http://127.0.0.1:13213/project/\" json_data = { \"title\": \"Notion tasks project threading\", \"description\": \"Threading notion tasks\", } response = requests.post(url, headers=headers, json=json_data).json() project_id = response[\"object\"][\"id\"] return project_id def create_none_category(project_id): url = f\"http://127.0.0.1:13213/project/{project_id}/category/\" json_data = { \"title\": \"None category\", \"description\": \"If no category, it falls here\", } response = requests.post(url, headers=headers, json=json_data).json() category_id = response[\"object\"][\"id\"] return category_id def main(): logger.reset_time() logger.info(\"\u041d\u0430\u0447\u0430\u043b \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435\") project_id = create_project() category_none_id = create_none_category(project_id) logger.info(\"\u0421\u043e\u0437\u0434\u0430\u043b \u043f\u0440\u043e\u0435\u043a\u0442 \u0438 none task\") task_pages = get_task_pages(db_id) logger.info(\"\u041f\u043e\u043b\u0443\u0447\u0438\u043b id \u0441\u0442\u0440\u0430\u043d\u0438\u0446 \u0442\u0430\u0441\u043a\u043e\u0432\") category_manager = CategoryManager(project_id, category_none_id) task_writer = TaskWriter(category_manager) with ThreadPoolExecutor() as executor: results = executor.map(task_writer.write_task_to_db, task_pages) try: for result in results: pass except Exception as e: print(e) logger.info(\"\u0421\u043e\u0431\u0440\u0430\u043b \u0432\u0441\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u043b \u0438\u0445 \u0432 \u0411\u0414\") if __name__ == \"__main__\": main()","title":"\u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0447\u0435\u0440\u0435\u0437 threading"}]}